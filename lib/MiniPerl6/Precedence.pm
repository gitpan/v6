# Do not edit this file - Generated by MiniPerl6 6.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc');
use MiniPerl6::Perl5::Runtime;
our $MATCH = MiniPerl6::Match->new();
{
package GLOBAL;
sub new { shift; bless { @_ }, "GLOBAL" }
{
package MiniPerl6::Precedence;
sub new { shift; bless { @_ }, "MiniPerl6::Precedence" }
sub get_token { $_[0]->{get_token} };
sub reduce { $_[0]->{reduce} };
sub end_token { $_[0]->{end_token} };
(my  $Operator = {  });
(my  $Precedence = {  });
(my  $Assoc = {  });
(my  $Allow_space_before = {  });
sub is_assoc_type { my $assoc_type = $_[0]; my $op_name = $_[1]; return($Assoc->{$assoc_type}->{$op_name}) };
sub is_fixity_type { my $fixity_type = $_[0]; my $op_name = $_[1]; return($Operator->{$fixity_type}->{$op_name}) };
sub is_term { my $token = $_[0]; ((($token->[0] eq 'term')) || (($token->[0] eq 'postfix_or_term'))) };
sub is_ident_middle { my $c = $_[0]; (((((($c ge 'a')) && (($c le 'z')))) || (((($c ge '0')) && (($c le '9'))))) || (($c eq '_'))) };
my  $Op1;
my  $Op2;
my  $End_token;
sub op_parse { my $self = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $from = $pos); for my $tok ( @{[@{(($End_token) || []) || []}] || []} ) { (my  $l = Main::chars($tok, )); (my  $s = substr($str, $pos, $l)); if (Main::bool(($s eq $tok))) { (my  $c1 = substr($str, (($pos + $l) - 1), 1)); (my  $c2 = substr($str, ($pos + $l), 1)); if (Main::bool((is_ident_middle($c1) && ((is_ident_middle($c2) || ($c2 eq '(')))))) {  } else { return(MiniPerl6::Match->new(('str' => $str), ('from' => $from), ('to' => ($pos + 2)), ('bool' => 1), ('capture' => ['end', $s]))) } }  }; (my  $c01 = substr($str, $pos, 1)); (my  $c02 = substr($str, $pos, 2)); (my  $hyper_left = 0); (my  $hyper_right = 0); if (Main::bool(((($c01 eq '«')) || (($c01 eq '»'))))) { ($hyper_left = $c01); ($pos = ($pos + 1)); ($c02 = substr($str, $pos, 2)) } else { if (Main::bool(((($c02 eq '<<')) || (($c02 eq '>>'))))) { ($hyper_left = $c02); ($pos = ($pos + 2)); ($c02 = substr($str, $pos, 2)) }  }; (my  $op2 = $c02); if (Main::bool(exists($Op2->{$op2}))) { (my  $c1 = substr($str, ($pos + 1), 1)); (my  $c2 = substr($str, ($pos + 2), 1)); if (Main::bool((is_ident_middle($c1) && ((is_ident_middle($c2) || ($c2 eq '(')))))) {  } else { ($pos = ($pos + 2)); (my  $c01 = substr($str, $pos, 1)); (my  $c02 = substr($str, $pos, 2)); if (Main::bool(((($c01 eq '«')) || (($c01 eq '»'))))) { ($hyper_right = $c01); ($pos = ($pos + 1)) } else { if (Main::bool(((($c02 eq '<<')) || (($c02 eq '>>'))))) { ($hyper_right = $c02); ($pos = ($pos + 2)) }  }; return(MiniPerl6::Match->new(('str' => $str), ('from' => $from), ('to' => $pos), ('bool' => 1), ('capture' => ['op', $op2, { ('hyper_left' => $hyper_left),('hyper_right' => $hyper_right), }]))) } } ; (my  $op1 = substr($str, $pos, 1)); if (Main::bool(exists($Op1->{$op1}))) { (my  $c2 = substr($str, ($pos + 1), 1)); if (Main::bool((is_ident_middle($op1) && ((is_ident_middle($c2) || ($c2 eq '(')))))) {  } else { ($pos = ($pos + 1)); (my  $c01 = substr($str, $pos, 1)); (my  $c02 = substr($str, $pos, 2)); if (Main::bool(((($c01 eq '«')) || (($c01 eq '»'))))) { ($hyper_right = $c01); ($pos = ($pos + 1)) } else { if (Main::bool(((($c02 eq '<<')) || (($c02 eq '>>'))))) { ($hyper_right = $c02); ($pos = ($pos + 2)) }  }; return(MiniPerl6::Match->new(('str' => $str), ('from' => $from), ('to' => $pos), ('bool' => 1), ('capture' => ['op', $op1, { ('hyper_left' => $hyper_left),('hyper_right' => $hyper_right), }]))) } } ; return(MiniPerl6::Match->new(('bool' => 0))) };
sub add_op { my $fixity = $_[0]; my $name = $_[1]; my $precedence = $_[2]; my $param = $_[3]; if (Main::bool(((defined($param)) ? 0 : 1))) { ($param = {  }) } ; (my  $assoc = ($param->{'assoc'} || 'left')); ($Operator->{$fixity}->{$name} = 1); ($Precedence->{$name} = $precedence); ($Assoc->{$assoc}->{$name} = 1); ($Allow_space_before->{$fixity}->{$name} = (Main::bool($param->{'no_space_before'}) ? 0 : 1)); if (Main::bool(((Main::chars($name, )) == 1))) { ($Op1->{$name} = 1) } else { if (Main::bool(((Main::chars($name, )) == 2))) { ($Op2->{$name} = 1) }  } };
(my  $prec = 100);
add_op('postfix', '.( )', $prec, { ('no_space_before' => 1), });
add_op('postfix', '.[ ]', $prec, { ('no_space_before' => 1), });
add_op('postfix', '.{ }', $prec, { ('no_space_before' => 1), });
add_op('postfix', '( )', $prec, { ('no_space_before' => 1), });
add_op('postfix', '[ ]', $prec, { ('no_space_before' => 1), });
add_op('postfix', 'funcall', $prec, { ('no_space_before' => 1), });
add_op('postfix', 'funcall_no_params', $prec, { ('no_space_before' => 1), });
add_op('postfix', 'methcall', $prec, { ('no_space_before' => 1), });
add_op('postfix', 'methcall_no_params', $prec, { ('no_space_before' => 1), });
add_op('postfix', 'block', $prec, { ('no_space_before' => 1), });
add_op('postfix', 'hash', $prec, { ('no_space_before' => 1), });
($prec = ($prec - 1));
add_op('prefix', '++', $prec);
add_op('prefix', '--', $prec);
add_op('postfix', '++', $prec, { ('no_space_before' => 1), });
add_op('postfix', '--', $prec, { ('no_space_before' => 1), });
($prec = ($prec - 1));
add_op('infix', '**', $prec, { ('assoc' => 'right'), });
($prec = ($prec - 1));
add_op('prefix', '+', $prec);
add_op('prefix', '-', $prec);
add_op('prefix', '$', $prec);
add_op('prefix', '@', $prec);
add_op('prefix', '%', $prec);
add_op('prefix', '!', $prec);
add_op('prefix', '?', $prec);
($prec = ($prec - 1));
add_op('infix', '*', $prec);
add_op('infix', '/', $prec);
($prec = ($prec - 1));
add_op('infix', '+', $prec);
add_op('infix', '-', $prec);
($prec = ($prec - 1));
add_op('infix', '~', $prec, { ('assoc' => 'list'), });
add_op('prefix', '~', $prec);
($prec = ($prec - 1));
add_op('infix', '&', $prec, { ('assoc' => 'list'), });
add_op('prefix', '&', $prec);
($prec = ($prec - 1));
add_op('infix', '|', $prec, { ('assoc' => 'list'), });
add_op('prefix', '|', $prec);
($prec = ($prec - 1));
add_op('infix', '<=>', $prec);
add_op('infix', 'leg', $prec);
add_op('infix', 'cmp', $prec);
add_op('infix', 'does', $prec);
add_op('infix', 'but', $prec);
add_op('infix', '..', $prec);
add_op('infix', '^..', $prec);
add_op('infix', '..^', $prec);
add_op('infix', '^..^', $prec);
($prec = ($prec - 1));
add_op('infix', 'ne', $prec, { ('assoc' => 'chain'), });
add_op('infix', 'eq', $prec, { ('assoc' => 'chain'), });
add_op('infix', 'lt', $prec, { ('assoc' => 'chain'), });
add_op('infix', 'le', $prec, { ('assoc' => 'chain'), });
add_op('infix', 'gt', $prec, { ('assoc' => 'chain'), });
add_op('infix', 'ge', $prec, { ('assoc' => 'chain'), });
add_op('infix', '<=', $prec, { ('assoc' => 'chain'), });
add_op('infix', '>=', $prec, { ('assoc' => 'chain'), });
add_op('infix', '==', $prec, { ('assoc' => 'chain'), });
add_op('infix', '!=', $prec, { ('assoc' => 'chain'), });
add_op('infix', '<', $prec, { ('assoc' => 'chain'), });
add_op('infix', '>', $prec, { ('assoc' => 'chain'), });
add_op('infix', '~~', $prec, { ('assoc' => 'chain'), });
($prec = ($prec - 1));
add_op('infix', '&&', $prec);
($prec = ($prec - 1));
add_op('infix', '||', $prec);
add_op('infix', '//', $prec);
($prec = ($prec - 1));
add_op('ternary', '?? !!', $prec);
($prec = ($prec - 1));
add_op('infix', '=', $prec, { ('assoc' => 'right'), });
add_op('infix', ':=', $prec, { ('assoc' => 'right'), });
($prec = ($prec - 1));
add_op('prefix', 'not', $prec);
($prec = ($prec - 1));
add_op('infix', '=>', $prec);
($prec = ($prec - 1));
add_op('list', ',', $prec, { ('assoc' => 'list'), });
($prec = ($prec - 1));
add_op('infix', 'and', $prec);
($prec = ($prec - 1));
add_op('infix', 'or', $prec);
($prec = ($prec - 1));
add_op('infix', '*start*', $prec);
sub precedence_parse { my $self = $_[0]; (my  $get_token = $self->get_token()); (my  $reduce = $self->reduce()); (my  $last_end_token = $End_token); ($End_token = $self->end_token()); (my  $op_stack = []); (my  $num_stack = []); (my  $last = ['op', '*start*']); (my  $last_has_space = 0); (my  $token = $get_token->()); if (Main::bool((($token->[0]) eq 'space'))) { ($token = $get_token->()) } ; for ( ; Main::bool(((defined($token)) && (($token->[0] ne 'end'))));  ) { if (Main::bool(((($token->[1] eq ',')) && (((($last->[1] eq '*start*')) || (($last->[1] eq ','))))))) { push( @{$num_stack}, ['term', undef] ) } ; if (Main::bool(($Operator->{'prefix'}->{$token->[1]} && (((($last->[1] eq '*start*')) || ((is_term($last)) ? 0 : 1)))))) { ($token->[0] = 'prefix'); unshift( @{$op_stack}, $token ) } else { if (Main::bool((($Operator->{'postfix'}->{$token->[1]} && is_term($last)) && (($Allow_space_before->{'postfix'}->{$token->[1]} || (($last_has_space) ? 0 : 1)))))) { (my  $pr = $Precedence->{$token->[1]}); for ( ; Main::bool((scalar( @{$op_stack} ) && (($pr <= $Precedence->{($op_stack->[0])->[1]}))));  ) { $reduce->($op_stack, $num_stack) }; if (Main::bool((($token->[0]) ne 'postfix_or_term'))) { ($token->[0] = 'postfix') } ; unshift( @{$op_stack}, $token ) } else { if (Main::bool((((($token->[1] eq 'block')) && is_term($last)) && $last_has_space))) { for ( ; Main::bool(scalar( @{$op_stack} ));  ) { $reduce->($op_stack, $num_stack) }; push( @{$num_stack}, $token ); ($End_token = $last_end_token); return($num_stack) } else { if (Main::bool(is_term($token))) { if (Main::bool(is_term($last))) { Main::say('#      last:  ', Main::perl($last, )); Main::say('#      token: ', Main::perl($token, )); Main::say('#      space: ', $last_has_space); die('Value tokens must be separated by an operator') } ; ($token->[0] = 'term'); push( @{$num_stack}, $token ) } else { if (Main::bool($Precedence->{$token->[1]})) { (my  $pr = $Precedence->{$token->[1]}); if (Main::bool($Assoc->{'right'}->{$token->[1]})) { for ( ; Main::bool((scalar( @{$op_stack} ) && (($pr < $Precedence->{($op_stack->[0])->[1]}))));  ) { $reduce->($op_stack, $num_stack) } } else { for ( ; Main::bool((scalar( @{$op_stack} ) && (($pr <= $Precedence->{($op_stack->[0])->[1]}))));  ) { $reduce->($op_stack, $num_stack) } }; if (Main::bool($Operator->{'ternary'}->{$token->[1]})) { ($token->[0] = 'ternary') } else { ($token->[0] = 'infix') }; unshift( @{$op_stack}, $token ) } else { die('Unknown token: \'', $token->[1], '\'') } } } } }; ($last = $token); ($token = $get_token->()); if (Main::bool(($token->[0] eq 'space'))) { ($token = $get_token->()); ($last_has_space = 1) } else { ($last_has_space = 0) } }; if (Main::bool((defined($token) && (($token->[0] ne 'end'))))) { die('Unexpected end token: ', Main::perl($token, )) } ; for ( ; Main::bool(scalar( @{$op_stack} ));  ) { $reduce->($op_stack, $num_stack) }; ($End_token = $last_end_token); return($num_stack) }
}


}

1;
