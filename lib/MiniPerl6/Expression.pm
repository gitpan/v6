# Do not edit this file - Generated by MiniPerl6 6.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc');
use MiniPerl6::Perl5::Runtime;
our $MATCH = MiniPerl6::Match->new();
{
package GLOBAL;
sub new { shift; bless { @_ }, "GLOBAL" }
{
package MiniPerl6::Expression;
sub new { shift; bless { @_ }, "MiniPerl6::Expression" }
use MiniPerl6::Precedence;
use MiniPerl6::Grammar;
use MiniPerl6::Perl5::Emitter;
sub expand_list { my $param_list = $_[0]; if (Main::bool(((Main::isa($param_list, 'Apply')) && ((($param_list->code()) eq 'list:<,>'))))) { (my  $args = []); for my $v ( @{[@{(($param_list->arguments()) || []) || []}] || []} ) { if (Main::bool(defined($v))) { push( @{$args}, $v ) }  }; return($args) } else { if (Main::bool(($param_list eq '*undef*'))) { return([]) } else { return([$param_list]) } } };
sub block_or_hash { my $o = $_[0]; if (Main::bool(defined($o->sig()))) { return($o) } ; (my  $stmts = $o->stmts()); if (Main::bool(((((defined($stmts)) ? 0 : 1)) || (((scalar( @{$stmts} )) == 0))))) { return(Lit::Hash->new(('hash1' => []))) } ; if (Main::bool(((scalar( @{$stmts} )) != 1))) { return($o) } ; (my  $stmt = $stmts->[0]); if (Main::bool(((Main::isa($stmt, 'Apply')) ? 0 : 1))) { return($o) } ; if (Main::bool((($stmt->code()) eq 'infix:<=>>'))) { return(Lit::Hash->new(('hash1' => [$stmt]))) } ; if (Main::bool((($stmt->code()) ne 'list:<,>'))) { return($o) } ; (my  $item = ($stmt->arguments())->[0]); if (Main::bool(((Main::isa($item, 'Apply')) ? 0 : 1))) { return($o) } ; if (Main::bool((($item->code()) eq 'infix:<=>>'))) { return(Lit::Hash->new(('hash1' => expand_list($stmt)))) } ; return($o) };
sub pop_term { my $num_stack = $_[0]; (my  $v = pop( @{$num_stack} )); if (Main::bool(Main::isa($v, 'Array'))) { if (Main::bool(($v->[1] eq 'methcall_no_params'))) { ($v = Call->new(('invocant' => undef), ('method' => $v->[2]), ('arguments' => undef), ('hyper' => $v->[3]))); return($v) } ; if (Main::bool(($v->[1] eq 'funcall_no_params'))) { ($v = Apply->new(('code' => $v->[3]), ('arguments' => undef), ('namespace' => $v->[2]))); return($v) } ; if (Main::bool(($v->[1] eq 'methcall'))) { if (Main::bool(($v->[3])->{'end_block'})) { unshift( @{$num_stack}, ($v->[3])->{'end_block'} ) } ; (my  $param_list = expand_list(($v->[3])->{'exp'})); ($v = Call->new(('invocant' => undef), ('method' => $v->[2]), ('arguments' => $param_list), ('hyper' => $v->[4]))); return($v) } ; if (Main::bool(($v->[1] eq 'funcall'))) { if (Main::bool(($v->[4])->{'end_block'})) { unshift( @{$num_stack}, ($v->[4])->{'end_block'} ) } ; (my  $param_list = expand_list(($v->[4])->{'exp'})); ($v = Apply->new(('code' => $v->[3]), ('arguments' => $param_list), ('namespace' => $v->[2]))); return($v) } ; if (Main::bool(($v->[1] eq '( )'))) { (my  $param_list = expand_list($v->[2])); ($v = Apply->new(('code' => 'circumfix:<( )>'), ('arguments' => $param_list), ('namespace' => ''))); return($v) } ; if (Main::bool(($v->[1] eq '[ ]'))) { (my  $param_list = expand_list($v->[2])); ($v = Lit::Array->new(('array1' => $param_list))); return($v) } ; if (Main::bool(($v->[1] eq 'block'))) { ($v = Lit::Block->new(('stmts' => $v->[2]), ('sig' => $v->[3]))); ($v = block_or_hash($v)); return($v) } ; if (Main::bool(($v->[1] eq '.( )'))) { ($v = Call->new(('invocant' => undef), ('method' => 'postcircumfix:<( )>'), ('arguments' => $v->[2]), ('hyper' => 0))); return($v) } ; if (Main::bool(($v->[1] eq '.[ ]'))) { ($v = Index->new(('obj' => undef), ('index_exp' => $v->[2]))); return($v) } ; if (Main::bool(($v->[1] eq '.{ }'))) { ($v = Lookup->new(('obj' => undef), ('index_exp' => $v->[2]))); return($v) } ; if (Main::bool((Main::isa(($v->[1]), 'Array') && (((scalar( @{($v->[1])} )) == 2))))) { ($v = Apply->new(('code' => 'pair'), ('arguments' => $v->[1]), ('namespace' => ''))); return($v) } ; return($v->[1]) } ; return($v) };
sub reduce_postfix { my $op = $_[0]; my $value = $_[1]; (my  $v = $op); if (Main::bool(($v->[1] eq 'methcall_no_params'))) { ($v = Call->new(('invocant' => $value), ('method' => $v->[2]), ('arguments' => undef), ('hyper' => $v->[3]))); return($v) } ; if (Main::bool(($v->[1] eq 'funcall_no_params'))) { die('unexpected function call'); push( @{$v}, $value ); return($v) } ; if (Main::bool(($v->[1] eq 'methcall'))) { (my  $param_list = expand_list(($v->[3])->{'exp'})); ($v = Call->new(('invocant' => $value), ('method' => $v->[2]), ('arguments' => $param_list), ('hyper' => $v->[4]))); return($v) } ; if (Main::bool(($v->[1] eq 'funcall'))) { die('unexpected function call'); push( @{$v}, $value ); return($v) } ; if (Main::bool(($v->[1] eq '( )'))) { (my  $param_list = expand_list($v->[2])); if (Main::bool((Main::isa($value, 'Apply') && ((defined($value->arguments())) ? 0 : 1)))) { (($value)->{arguments} = $param_list); return($value) } ; if (Main::bool((Main::isa($value, 'Call') && ((defined($value->arguments())) ? 0 : 1)))) { (($value)->{arguments} = $param_list); return($value) } ; ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:<( )>'), ('arguments' => $param_list), ('hyper' => 0))); return($v) } ; if (Main::bool(($v->[1] eq '[ ]'))) { ($v = Index->new(('obj' => $value), ('index_exp' => $v->[2]))); return($v) } ; if (Main::bool(($v->[1] eq 'block'))) { ($v = Lookup->new(('obj' => $value), ('index_exp' => ($v->[2])->[0]))); return($v) } ; if (Main::bool(($v->[1] eq '.( )'))) { (my  $param_list = expand_list($v->[2])); ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:<( )>'), ('arguments' => $param_list), ('hyper' => 0))); return($v) } ; if (Main::bool(($v->[1] eq '.[ ]'))) { ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:<[ ]>'), ('arguments' => $v->[2]), ('hyper' => 0))); return($v) } ; if (Main::bool(($v->[1] eq '.{ }'))) { ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:<{ }>'), ('arguments' => $v->[2]), ('hyper' => 0))); return($v) } ; push( @{$op}, $value ); return($op) };
(my  $reduce_to_ast = sub  { my $op_stack = $_[0]; my $num_stack = $_[1]; (my  $last_op = shift( @{$op_stack} )); if (Main::bool(($last_op->[0] eq 'prefix'))) { push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'prefix:<' . $last_op->[1] . '>'), ('arguments' => [pop_term($num_stack)])) ) } else { if (Main::bool(($last_op->[0] eq 'postfix'))) { push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'postfix:<' . $last_op->[1] . '>'), ('arguments' => [pop_term($num_stack)])) ) } else { if (Main::bool(($last_op->[0] eq 'postfix_or_term'))) { push( @{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)) ) } else { if (Main::bool(MiniPerl6::Precedence::is_assoc_type('list', $last_op->[1]))) { my  $arg; if (Main::bool((scalar( @{$num_stack} ) < 2))) { (my  $v2 = pop_term($num_stack)); if (Main::bool(((Main::isa($v2, 'Apply')) && (($v2->code() eq ('list:<' . $last_op->[1] . '>')))))) { push( @{($v2->arguments())}, undef ); push( @{$num_stack}, $v2 ) } else { push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'list:<' . $last_op->[1] . '>'), ('arguments' => [$v2, undef])) ) }; return() } else { (my  $v2 = pop_term($num_stack)); ($arg = [pop_term($num_stack), $v2]) }; if (Main::bool((((Main::isa(($arg->[0]), 'Apply')) && (($last_op->[0] eq 'infix'))) && ((($arg->[0])->code() eq ('list:<' . $last_op->[1] . '>')))))) { push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => ($arg->[0])->code()), ('arguments' => [@{((($arg->[0])->arguments()) || []) || []}, $arg->[1]])) ); return() } ; push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'list:<' . $last_op->[1] . '>'), ('arguments' => $arg)) ) } else { if (Main::bool(MiniPerl6::Precedence::is_assoc_type('chain', $last_op->[1]))) { if (Main::bool((scalar( @{$num_stack} ) < 2))) { die('Missing value after operator ' . $last_op->[1]) } ; (my  $v2 = pop_term($num_stack)); (my  $arg = [pop_term($num_stack), $v2]); push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'infix:<' . $last_op->[1] . '>'), ('arguments' => $arg)) ) } else { if (Main::bool(($last_op->[0] eq 'ternary'))) { if (Main::bool(((scalar( @{$num_stack} ) < 2)))) { die('Missing value after ternary operator') } ; (my  $v2 = pop_term($num_stack)); push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'ternary:<' . $last_op->[1] . '>'), ('arguments' => [pop_term($num_stack), $last_op->[2], $v2])) ) } else { if (Main::bool(((scalar( @{$num_stack} ) < 2)))) { die('missing value after operator \'' . $last_op->[1] . '\'') } ; (my  $v2 = pop_term($num_stack)); push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'infix:<' . $last_op->[1] . '>'), ('arguments' => [pop_term($num_stack), $v2])) ) } } } } } } });
sub capture_name { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((do { do { (my  $m2 = MiniPerl6::Grammar->full_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.full_ident'} = $m2); 1 } else { 0 } } }) && (do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $pos1 = $MATCH->to()); (do { do { ((((Main::bool((('.' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = MiniPerl6::Grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); if (Main::bool(exists($MATCH->{'MiniPerl6::Grammar.ident'}))) { push( @{($MATCH->{'MiniPerl6::Grammar.ident'})}, $m2 ) } else { ($MATCH->{'MiniPerl6::Grammar.ident'} = [$m2]) }; 1 } else { 0 } } }))) } }) } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } }))) } }) } }))); $MATCH };
sub hyper_op { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { ((Main::bool((('>>' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0)) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) } }) } }))); $MATCH };
sub operator { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (((((((((((((((((((((((((((((do { do { ((((((Main::bool((('.(' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->paren_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'paren_parse'} = $m2); 1 } else { 0 } } })) && ((Main::bool(((')' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (['postfix_or_term', '.( )', ${$MATCH->{'paren_parse'}}])) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('.[' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->square_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'square_parse'} = $m2); 1 } else { 0 } } })) && ((Main::bool(((']' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (['postfix_or_term', '.[ ]', ${$MATCH->{'square_parse'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('.{' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->curly_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'curly_parse'} = $m2); 1 } else { 0 } } })) && ((Main::bool((('}' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (['postfix_or_term', '.{ }', ${$MATCH->{'curly_parse'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('(' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->paren_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'paren_parse'} = $m2); 1 } else { 0 } } })) && ((Main::bool(((')' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (['postfix_or_term', '( )', ${$MATCH->{'paren_parse'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('[' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->square_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'square_parse'} = $m2); 1 } else { 0 } } })) && ((Main::bool(((']' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (['postfix_or_term', '[ ]', ${$MATCH->{'square_parse'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('->' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0)) && (do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) && (do { do { (my  $m2 = $grammar->list_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'list_parse'} = $m2); 1 } else { 0 } } })) && (((do { do { (my  $block = (${$MATCH->{'list_parse'}})->{'end_block'}); if (Main::bool($block->sig())) { die('Signature error in block') } ; ($MATCH->{capture} = (['postfix_or_term', 'block', $block->stmts(), (${$MATCH->{'list_parse'}})->{'exp'}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((((Main::bool((('{' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) && (do { do { (my  $m2 = MiniPerl6::Grammar->exp_stmts($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.exp_stmts'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) && ((Main::bool((('}' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (['postfix_or_term', 'block', ${$MATCH->{'MiniPerl6::Grammar.exp_stmts'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('method' eq substr($str, $MATCH->to(), 6)))) ? ((1 + ((($MATCH)->{to} = (6 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = MiniPerl6::Grammar->method_def($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.method_def'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (['term', ${$MATCH->{'MiniPerl6::Grammar.method_def'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('sub' eq substr($str, $MATCH->to(), 3)))) ? ((1 + ((($MATCH)->{to} = (3 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = MiniPerl6::Grammar->sub_def($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.sub_def'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (['term', ${$MATCH->{'MiniPerl6::Grammar.sub_def'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('token' eq substr($str, $MATCH->to(), 5)))) ? ((1 + ((($MATCH)->{to} = (5 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = MiniPerl6::Grammar->token($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.token'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (['term', ${$MATCH->{'MiniPerl6::Grammar.token'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('do' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->statement_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'statement_parse'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (['term', Do->new(('block' => ${$MATCH->{'statement_parse'}}))])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('??' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->ternary_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'ternary_parse'} = $m2); 1 } else { 0 } } })) && ((Main::bool((('!!' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (['op', '?? !!', ${$MATCH->{'ternary_parse'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = MiniPerl6::Grammar->var_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.var_ident'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (['term', ${$MATCH->{'MiniPerl6::Grammar.var_ident'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('$<' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->capture_name($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'capture_name'} = $m2); 1 } else { 0 } } })) && ((Main::bool((('>' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (['term', Lookup->new(('obj' => Var->new(('sigil' => '$'), ('twigil' => ''), ('name' => '/'))), ('index_exp' => Val::Buf->new(('buf' => ("" . $MATCH->{'capture_name'})))))])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = MiniPerl6::Precedence->op_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Precedence.op_parse'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'MiniPerl6::Precedence.op_parse'}})) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { (my  $m2 = MiniPerl6::Grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.ident'} = $m2); 1 } else { 0 } } }) && (do { do { (my  $tmp = $MATCH); ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { (((do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } }) && ((Main::bool((('=>' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0)))) } }) } })); (($tmp)->{bool} = ($MATCH ? 1 : 0)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } })) && (((do { do { ($MATCH->{capture} = (['term', Val::Buf->new(('buf' => ("" . $MATCH->{'MiniPerl6::Grammar.ident'})))])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((((Main::bool((('True' eq substr($str, $MATCH->to(), 4)))) ? ((1 + ((($MATCH)->{to} = (4 + $MATCH->to()))))) : 0)) && (do { do { (my  $tmp = $MATCH); ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((do { do { (my  $m2 = MiniPerl6::Grammar->word($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('(' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) } })) } }) } })); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } })) && (((do { do { ($MATCH->{capture} = (['term', Val::Bit->new(('bit' => 1))])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((((Main::bool((('False' eq substr($str, $MATCH->to(), 5)))) ? ((1 + ((($MATCH)->{to} = (5 + $MATCH->to()))))) : 0)) && (do { do { (my  $tmp = $MATCH); ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((do { do { (my  $m2 = MiniPerl6::Grammar->word($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('(' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) } })) } }) } })); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } })) && (((do { do { ($MATCH->{capture} = (['term', Val::Bit->new(('bit' => 0))])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((((Main::bool((('and' eq substr($str, $MATCH->to(), 3)))) ? ((1 + ((($MATCH)->{to} = (3 + $MATCH->to()))))) : 0)) && (do { do { (my  $tmp = $MATCH); ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((do { do { (my  $m2 = MiniPerl6::Grammar->word($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('(' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) } })) } }) } })); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } })) && (((do { do { ($MATCH->{capture} = (['op', 'and'])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((((Main::bool((('not' eq substr($str, $MATCH->to(), 3)))) ? ((1 + ((($MATCH)->{to} = (3 + $MATCH->to()))))) : 0)) && (do { do { (my  $tmp = $MATCH); ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((do { do { (my  $m2 = MiniPerl6::Grammar->word($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('(' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) } })) } }) } })); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } })) && (((do { do { ($MATCH->{capture} = (['op', 'not'])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((((Main::bool((('use' eq substr($str, $MATCH->to(), 3)))) ? ((1 + ((($MATCH)->{to} = (3 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = MiniPerl6::Grammar->full_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.full_ident'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $pos1 = $MATCH->to()); (do { do { ((((Main::bool((('-' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = MiniPerl6::Grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); if (Main::bool(exists($MATCH->{'MiniPerl6::Grammar.ident'}))) { push( @{($MATCH->{'MiniPerl6::Grammar.ident'})}, $m2 ) } else { ($MATCH->{'MiniPerl6::Grammar.ident'} = [$m2]) }; 1 } else { 0 } } }))) } }) } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) && (do { do { (my  $m2 = $grammar->list_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'list_parse'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (['term', Use->new(('mod' => ${$MATCH->{'MiniPerl6::Grammar.full_ident'}}))])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((((do { do { (my  $pos1 = $MATCH->to()); (((do { do { (((Main::bool((('package' eq substr($str, $MATCH->to(), 7)))) ? ((1 + ((($MATCH)->{to} = (7 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('class' eq substr($str, $MATCH->to(), 5)))) ? ((1 + ((($MATCH)->{to} = (5 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('grammar' eq substr($str, $MATCH->to(), 7)))) ? ((1 + ((($MATCH)->{to} = (7 + $MATCH->to()))))) : 0))) } })) } }) && (do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = MiniPerl6::Grammar->grammar($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.grammar'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (['term', ${$MATCH->{'MiniPerl6::Grammar.grammar'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((((((do { do { (my  $m2 = MiniPerl6::Grammar->declarator($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.declarator'} = $m2); 1 } else { 0 } } }) && (do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = MiniPerl6::Grammar->opt_type($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.opt_type'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $m2 = MiniPerl6::Grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = MiniPerl6::Grammar->var_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.var_ident'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (['term', Decl->new(('decl' => ${$MATCH->{'MiniPerl6::Grammar.declarator'}}), ('type' => ${$MATCH->{'MiniPerl6::Grammar.opt_type'}}), ('var' => ${$MATCH->{'MiniPerl6::Grammar.var_ident'}}))])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('.' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->hyper_op($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'hyper_op'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $m2 = MiniPerl6::Grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.ident'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((((do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (do { do { (my  $m2 = $grammar->list_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'list_parse'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (['postfix_or_term', 'methcall', ("" . $MATCH->{'MiniPerl6::Grammar.ident'}), ${$MATCH->{'list_parse'}}, ${$MATCH->{'hyper_op'}}])) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { ($MATCH->{capture} = (['postfix_or_term', 'methcall_no_params', ("" . $MATCH->{'MiniPerl6::Grammar.ident'}), ${$MATCH->{'hyper_op'}}])) } }) || 1))) } })) } }))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { (my  $m2 = MiniPerl6::Grammar->optional_namespace_before_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.optional_namespace_before_ident'} = $m2); 1 } else { 0 } } }) && (do { do { (my  $m2 = MiniPerl6::Grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.ident'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $pos1 = $MATCH->to()); (((do { do { ((((do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (do { do { (my  $m2 = $grammar->list_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'list_parse'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (['postfix_or_term', 'funcall', ("" . $MATCH->{'MiniPerl6::Grammar.optional_namespace_before_ident'}), ("" . $MATCH->{'MiniPerl6::Grammar.ident'}), ${$MATCH->{'list_parse'}}])) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $tmp = $MATCH); ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('.' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) } })); (($tmp)->{bool} = ($MATCH ? 1 : 0)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }) && (((do { do { (my  $namespace = ("" . $MATCH->{'MiniPerl6::Grammar.optional_namespace_before_ident'})); (my  $name = ("" . $MATCH->{'MiniPerl6::Grammar.ident'})); if (Main::bool($namespace)) { ($name = $namespace . '::' . $name) } ; ($MATCH->{capture} = (['term', Proto->new(('name' => $name))])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { ($MATCH->{capture} = (['postfix_or_term', 'funcall_no_params', ("" . $MATCH->{'MiniPerl6::Grammar.optional_namespace_before_ident'}), ("" . $MATCH->{'MiniPerl6::Grammar.ident'})])) } }) || 1))) } })) } }))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = MiniPerl6::Grammar->val_num($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.val_num'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (['term', ${$MATCH->{'MiniPerl6::Grammar.val_num'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = MiniPerl6::Grammar->val_int($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.val_int'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (['term', ${$MATCH->{'MiniPerl6::Grammar.val_int'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = MiniPerl6::Grammar->val_buf($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.val_buf'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (['term', ${$MATCH->{'MiniPerl6::Grammar.val_buf'}}])) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (['space', ' '])) } }) || 1)))) } })) } }))); $MATCH };
sub has_newline_after { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (((do { do { (((Main::bool((('#' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((do { do { (my  $m2 = MiniPerl6::Grammar->is_newline($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = MiniPerl6::Grammar->space($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (do { do { (my  $m2 = $grammar->has_newline_after($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } })) } }))); $MATCH };
sub has_no_comma_or_colon_after { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((((do { do { (my  $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (do { do { (my  $tmp = $MATCH); ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { (((Main::bool(((',' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool(((':' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) } })) } }) } })); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } })) && ((Main::bool((('' ne substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)))) } }) } }))); $MATCH };
sub list_parse { my $self = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $expr; (my  $last_pos = $pos); (my  $is_first_token = 1); (my  $lexer_stack = []); (my  $terminated = 0); (my  $last_token_was_space = 1); (my  $get_token = sub  { my  $v; if (Main::bool(scalar( @{$lexer_stack} ))) { ($v = pop( @{$lexer_stack} )); if (Main::bool((($is_first_token && (($v->[0] eq 'op'))) && ((MiniPerl6::Precedence::is_fixity_type('prefix', $v->[1])) ? 0 : 1)))) { ($v->[0] = 'end') }  } else { (my  $m = $self->operator($str, $last_pos)); if (Main::bool(($m ? 0 : 1))) { return(['end', '*end*']) } ; ($v = ${$m}); if (Main::bool((($is_first_token && (($v->[0] eq 'op'))) && ((MiniPerl6::Precedence::is_fixity_type('prefix', $v->[1])) ? 0 : 1)))) { ($v->[0] = 'end') } ; if (Main::bool(($v->[0] ne 'end'))) { ($last_pos = $m->to()) }  }; if (Main::bool(((((($v->[0]) eq 'postfix_or_term')) && ((($v->[1]) eq 'block'))) && $last_token_was_space))) { if (Main::bool($self->has_newline_after($str, $last_pos))) { ($terminated = 1); push( @{$lexer_stack}, ['end', '*end*'] ) } else { if (Main::bool($self->has_no_comma_or_colon_after($str, $last_pos))) { ($terminated = 1); push( @{$lexer_stack}, ['end', '*end*'] ) }  } } ; ($last_token_was_space = (($v->[0] eq 'space'))); ($is_first_token = 0); return($v) }); (my  $prec = MiniPerl6::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => ['and', 'or', '!!', ']', ')', '}', ';', 'if', 'else', 'elsif', 'unless', 'when', 'for', 'while', 'loop']))); (my  $res = $prec->precedence_parse()); if (Main::bool((scalar( @{$res} ) == 0))) { return(MiniPerl6::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => { ('exp' => '*undef*'),('end_block' => undef),('terminated' => undef), }))) } ; my  $block; if (Main::bool((scalar( @{$res} ) > 1))) { ($block = pop( @{$res} )); ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3]))) } ; (my  $result = pop_term($res)); if (Main::bool((scalar( @{$res} ) > 0))) { ($block = pop( @{$res} )); ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3]))) } ; return(MiniPerl6::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => { ('exp' => $result),('end_block' => $block),('terminated' => $terminated), }))) };
sub circumfix_parse { my $self = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $delimiter = $_[3]; my  $expr; (my  $last_pos = $pos); (my  $get_token = sub  { (my  $m = $self->operator($str, $last_pos)); if (Main::bool(($m ? 0 : 1))) { die('Expected closing delimiter: ', (($delimiter) || []), ' near ', $last_pos) } ; (my  $v = ${$m}); if (Main::bool(($v->[0] ne 'end'))) { ($last_pos = $m->to()) } ; return($v) }); (my  $prec = MiniPerl6::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => $delimiter))); (my  $res = $prec->precedence_parse()); ($res = pop_term($res)); if (Main::bool(((defined($res)) ? 0 : 1))) { ($res = '*undef*') } ; return(MiniPerl6::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => $res))) };
sub ternary_parse { my $self = $_[0]; my $str = $_[1]; my $pos = $_[2]; return($self->circumfix_parse($str, $pos, ['!!'])) };
sub curly_parse { my $self = $_[0]; my $str = $_[1]; my $pos = $_[2]; return($self->circumfix_parse($str, $pos, ['}'])) };
sub square_parse { my $self = $_[0]; my $str = $_[1]; my $pos = $_[2]; return($self->circumfix_parse($str, $pos, [']'])) };
sub paren_parse { my $self = $_[0]; my $str = $_[1]; my $pos = $_[2]; return($self->circumfix_parse($str, $pos, [')'])) };
sub exp_parse { my $self = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $expr; (my  $last_pos = $pos); (my  $lexer_stack = []); (my  $terminated = 0); (my  $get_token = sub  { my  $v; if (Main::bool(scalar( @{$lexer_stack} ))) { ($v = pop( @{$lexer_stack} )) } else { (my  $m = $self->operator($str, $last_pos)); if (Main::bool(($m ? 0 : 1))) { return(['end', '*end*']) } ; ($v = ${$m}); if (Main::bool(($v->[0] ne 'end'))) { ($last_pos = $m->to()) }  }; if (Main::bool(((((((((($v->[0]) eq 'postfix_or_term')) && ((($v->[1]) eq 'block')))) || ((((($v->[0]) eq 'term')) && (Main::isa(($v->[1]), 'Sub'))))) || ((((($v->[0]) eq 'term')) && (Main::isa(($v->[1]), 'Method'))))) || ((((($v->[0]) eq 'term')) && (Main::isa(($v->[1]), 'Do'))))) || ((((($v->[0]) eq 'term')) && (Main::isa(($v->[1]), 'CompUnit'))))))) { if (Main::bool($self->has_newline_after($str, $last_pos))) { ($terminated = 1); push( @{$lexer_stack}, ['end', '*end*'] ) }  } ; return($v) }); (my  $prec = MiniPerl6::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => [']', ')', '}', ';', 'if', 'else', 'elsif', 'unless', 'when', 'for', 'while', 'loop']))); (my  $res = $prec->precedence_parse()); if (Main::bool((scalar( @{$res} ) == 0))) { return(MiniPerl6::Match->new(('bool' => 0))) } ; my  $block; if (Main::bool((scalar( @{$res} ) > 1))) { ($block = pop( @{$res} )); ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3]))) } ; (my  $result = pop_term($res)); if (Main::bool((scalar( @{$res} ) > 0))) { ($block = pop( @{$res} )); if (Main::bool(((Main::isa($block, 'Lit::Block')) ? 0 : 1))) { ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3]))) }  } ; return(MiniPerl6::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => { ('exp' => $result),('end_block' => $block),('terminated' => $terminated), }))) };
sub exp_stmt { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); ((((((do { do { (((do { do { (my  $m2 = MiniPerl6::Grammar->if($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.if'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'MiniPerl6::Grammar.if'}})) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = MiniPerl6::Grammar->unless($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.unless'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'MiniPerl6::Grammar.unless'}})) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = MiniPerl6::Grammar->when($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.when'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'MiniPerl6::Grammar.when'}})) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = MiniPerl6::Grammar->for($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.for'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'MiniPerl6::Grammar.for'}})) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = MiniPerl6::Grammar->while($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.while'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'MiniPerl6::Grammar.while'}})) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = MiniPerl6::Grammar->loop($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'MiniPerl6::Grammar.loop'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'MiniPerl6::Grammar.loop'}})) } }) || 1)))) } })) } }))); $MATCH };
sub statement_modifier { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = MiniPerl6::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); ((((((do { do { (((Main::bool((('if' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('unless' eq substr($str, $MATCH->to(), 6)))) ? ((1 + ((($MATCH)->{to} = (6 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('when' eq substr($str, $MATCH->to(), 4)))) ? ((1 + ((($MATCH)->{to} = (4 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('for' eq substr($str, $MATCH->to(), 3)))) ? ((1 + ((($MATCH)->{to} = (3 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('while' eq substr($str, $MATCH->to(), 5)))) ? ((1 + ((($MATCH)->{to} = (5 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('loop' eq substr($str, $MATCH->to(), 4)))) ? ((1 + ((($MATCH)->{to} = (4 + $MATCH->to()))))) : 0))) } })) } }))); $MATCH };
sub statement_parse { my $self = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $expr; (my  $last_pos = $pos); (my  $lexer_stack = []); (my  $spaces = MiniPerl6::Grammar->ws($str, $pos)); if (Main::bool($spaces)) { ($pos = $spaces->to()) } ; (my  $res = $self->exp_stmt($str, $pos)); if (Main::bool($res)) { return($res) } ; ($res = $self->exp_parse($str, $pos)); if (Main::bool((($res) ? 0 : 1))) { return($res) } ; if (Main::bool(Main::isa((${$res})->{'exp'}, 'Lit::Block'))) { ((${$res})->{'exp'} = Do->new(('block' => (${$res})->{'exp'}))) } ; if (Main::bool((${$res})->{'end_block'})) { die('Unexpected block after expression near ', $pos) } ; if (Main::bool((${$res})->{'terminated'})) { (($res)->{capture} = (${$res})->{'exp'}); return($res) } ; (my  $modifier = $self->statement_modifier($str, $res->to())); if (Main::bool((($modifier) ? 0 : 1))) { (($res)->{capture} = (${$res})->{'exp'}); return($res) } ; (my  $modifier_exp = $self->exp_parse($str, $modifier->to())); if (Main::bool((($modifier_exp) ? 0 : 1))) { die('Expected expression after \'', $modifier, '\'') } ; if (Main::bool((${$modifier_exp})->{'end_block'})) { die('Unexpected block after expression near ', $modifier->to()) } ; return(MiniPerl6::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => { ('exp' => (${$res})->{'exp'}),('modifier' => ("" . $modifier)),('modifier_exp' => (${$modifier_exp})->{'exp'}), }))) }
}


}

1;
