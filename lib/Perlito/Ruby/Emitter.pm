# Do not edit this file - Generated by Perlito 7.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito::Perl5::Runtime;
use Perlito::Perl5::Prelude;
our $MATCH = Perlito::Match->new();
{
package GLOBAL;
    sub new { shift; bless { @_ }, "GLOBAL" }

    # use v6 
;
    {
    package Ruby;
        sub new { shift; bless { @_ }, "Ruby" }
        sub to_str {
            my $op = $_[0];
            my $args = $_[1];
            (my  $List_s = bless [], 'ARRAY');
            for my $cond ( @{(($args))} ) {
                if (Main::isa($cond, 'Val::Buf')) {
                    push( @{$List_s}, $cond->emit_ruby() )
                }
                else {
                    push( @{$List_s}, ('(' . $cond->emit_ruby() . ').to_s') )
                }
            };
            return scalar (('(' . Main::join($List_s, $op) . ')'))
        };
        sub to_num {
            my $op = $_[0];
            my $args = $_[1];
            (my  $List_s = bless [], 'ARRAY');
            for my $cond ( @{(($args))} ) {
                if (((Main::isa($cond, 'Val::Int')) || (Main::isa($cond, 'Val::Num')))) {
                    push( @{$List_s}, $cond->emit_ruby() )
                }
                else {
                    push( @{$List_s}, ('mp6_to_num(' . $cond->emit_ruby() . ')') )
                }
            };
            return scalar (('(' . Main::join($List_s, $op) . ')'))
        };
        sub to_bool {
            my $op = $_[0];
            my $args = $_[1];
            (my  $List_s = bless [], 'ARRAY');
            for my $cond ( @{(($args))} ) {
                if (((Main::isa($cond, 'Val::Int')) || (Main::isa($cond, 'Val::Num')))) {
                    push( @{$List_s}, ('(' . $cond->emit_ruby() . ' ' . chr(33) . chr(61) . ' 0 )') )
                }
                else {
                    if ((((((((Main::isa($cond, 'Apply')) && (($cond->code() eq 'infix:<' . chr(124) . chr(124) . '>')))) || (((Main::isa($cond, 'Apply')) && (($cond->code() eq 'infix:<' . chr(38) . chr(38) . '>'))))) || (((Main::isa($cond, 'Apply')) && (($cond->code() eq 'prefix:<' . chr(33) . '>'))))) || (((Main::isa($cond, 'Apply')) && (($cond->code() eq 'prefix:<' . chr(63) . '>'))))) || (Main::isa($cond, 'Val::Bit')))) {
                        push( @{$List_s}, $cond->emit_ruby() )
                    }
                    else {
                        push( @{$List_s}, ('mp6_to_bool(' . $cond->emit_ruby() . ')') )
                    }
                }
            };
            return scalar (('(' . Main::join($List_s, $op) . ')'))
        };
        sub tab {
            my $level = $_[0];
            (('    ') x $level)
        }
    }

;
    {
    package Perlito::Ruby::AnonSub;
        sub new { shift; bless { @_ }, "Perlito::Ruby::AnonSub" }
        sub name { $_[0]->{name} };
        sub sig { $_[0]->{sig} };
        sub block { $_[0]->{block} };
        sub handles_return_exception { $_[0]->{handles_return_exception} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $sig) = $self->{sig});
            ((my  $pos) = $sig->positional());
            ((my  $args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            for my $field ( @{($pos)} ) {
                push( @{$args}, $field->emit_ruby_name() )
            };
            ((my  $block) = Perlito::Ruby::LexicalBlock->new(('block' => $self->{block}), ('needs_return' => 1)));
            (my  $List_s = bless [], 'ARRAY');
            push( @{$List_s}, (Ruby::tab($level) . (($self->{name} ? (('f_' . $self->{name} . (' ' . chr(61) . ' '))) : '')) . ('lambda' . chr(123) . ' ' . chr(124)) . Main::join($args, (', ')) . (chr(124) . ' ')) );
            push( @{$List_s}, $block->emit_ruby_indented(($level + 1)) );
            push( @{$List_s}, (Ruby::tab($level) . (chr(125))) );
            return scalar (Main::join($List_s, (chr(10))))
        }
    }

;
    {
    package Perlito::Ruby::LexicalBlock;
        sub new { shift; bless { @_ }, "Perlito::Ruby::LexicalBlock" }
        sub block { $_[0]->{block} };
        sub needs_return { $_[0]->{needs_return} };
        sub top_level { $_[0]->{top_level} };
        (my  $ident);
        (my  $List_anon_block = bless [], 'ARRAY');
        sub push_stmt_ruby {
            my $block = $_[0];
            push( @{$List_anon_block}, $block )
        };
        sub get_ident_ruby {
            ($ident = ($ident + 1));
            return scalar ($ident)
        };
        sub has_my_decl {
            my $self = $_[0];
            for my $decl ( @{$self->{block}} ) {
                if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'my')))) {
                    return scalar (1)
                };
                if (((Main::isa($decl, 'Bind') && Main::isa(($decl->parameters()), 'Decl')) && ((($decl->parameters())->decl() eq 'my')))) {
                    return scalar (1)
                }
            };
            return scalar (0)
        };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            if (!(($self->{block}))) {
                push( @{$self->{block}}, Val::Undef->new() )
            };
            (my  $List_s = bless [], 'ARRAY');
            (my  $List_tmp = bless [], 'ARRAY');
            for my $stmt ( @{$List_anon_block} ) {
                push( @{$List_tmp}, $stmt )
            };
            ((my  $has_decl) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            ((my  $block) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            for my $decl ( @{$self->{block}} ) {
                if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'has')))) {
                    push( @{$has_decl}, $decl )
                }
                else {
                    if (((Main::isa($decl, 'Bind') && Main::isa(($decl->parameters()), 'Decl')) && ((($decl->parameters())->decl() eq 'has')))) {
                        push( @{$has_decl}, $decl )
                    }
                    else {
                        push( @{$block}, $decl )
                    }
                }
            };
            if ((($has_decl))) {
                for my $decl ( @{(($has_decl))} ) {
                    if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'has')))) {
                        push( @{$List_s}, (Ruby::tab($level) . 'attr_accessor :v_' . ($decl->var())->name()) );
                        push( @{$List_s}, (Ruby::tab($level) . 'def f_' . ($decl->var())->name() . '()') );
                        push( @{$List_s}, (Ruby::tab(($level + 1)) . 'return self.v_' . ($decl->var())->name()) );
                        push( @{$List_s}, (Ruby::tab($level) . ('end')) )
                    };
                    if (((Main::isa($decl, 'Bind') && Main::isa(($decl->parameters()), 'Decl')) && ((($decl->parameters())->decl() eq 'has')))) {
                        push( @{$List_s}, (Ruby::tab($level) . 'attr_accessor :v_' . (($decl->parameters())->var())->name()) );
                        push( @{$List_s}, (Ruby::tab($level) . 'def f_' . (($decl->parameters())->var())->name() . '()') );
                        push( @{$List_s}, (Ruby::tab(($level + 1)) . 'return self.v_' . (($decl->parameters())->var())->name()) );
                        push( @{$List_s}, (Ruby::tab($level) . ('end')) )
                    }
                }
            };
            ((my  $has_my_decl) = 0);
            (my  $List_my_decl = bless [], 'ARRAY');
            (my  $List_my_init = bless [], 'ARRAY');
            (my  $Hash_my_seen = bless {}, 'HASH');
            for my $decl ( @{(($block))} ) {
                if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'my')))) {
                    if (!(($Hash_my_seen->{($decl->var())->name()}))) {
                        push( @{$List_my_decl}, ($decl->var())->emit_ruby_name() );
                        push( @{$List_my_init}, $decl->emit_ruby_init() );
                        ($has_my_decl = 1);
                        ($Hash_my_seen->{($decl->var())->name()} = 1)
                    }
                };
                if (((Main::isa($decl, 'Bind') && Main::isa(($decl->parameters()), 'Decl')) && ((($decl->parameters())->decl() eq 'my')))) {
                    if (!(($Hash_my_seen->{(($decl->parameters())->var())->name()}))) {
                        push( @{$List_my_decl}, (($decl->parameters())->var())->emit_ruby_name() );
                        push( @{$List_my_init}, ($decl->parameters())->emit_ruby_init() );
                        ($has_my_decl = 1);
                        ($Hash_my_seen->{(($decl->parameters())->var())->name()} = 1)
                    }
                }
            };
            if ($has_my_decl) {
                push( @{$List_s}, (Ruby::tab($level) . ('Proc.new' . chr(123) . ' ' . chr(124)) . Main::join($List_my_decl, (', ')) . (chr(124))) );
                ($level = ($level + 1))
            };
            (my  $last_statement);
            if ($self->{needs_return}) {
                ($last_statement = pop( @{$block} ))
            };
            for my $stmt ( @{(($block))} ) {
                ($List_anon_block = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
                ((my  $s2) = $stmt->emit_ruby_indented($level));
                for my $stmt ( @{$List_anon_block} ) {
                    push( @{$List_s}, $stmt->emit_ruby_indented($level) )
                };
                push( @{$List_s}, $s2 )
            };
            if (($self->{needs_return} && $last_statement)) {
                ($List_anon_block = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
                (my  $s2);
                if (Main::isa($last_statement, 'If')) {
                    ((my  $cond) = $last_statement->cond());
                    ((my  $has_otherwise) = ($last_statement->otherwise() ? 1 : 0));
                    ((my  $body_block) = Perlito::Ruby::LexicalBlock->new(('block' => ($last_statement->body()->stmts())), ('needs_return' => 1)));
                    ((my  $otherwise_block) = Perlito::Ruby::LexicalBlock->new(('block' => ($last_statement->otherwise()->stmts())), ('needs_return' => 1)));
                    if ($body_block->has_my_decl()) {
                        ($body_block = Return->new(('result' => Do->new(('block' => ($last_statement->body()))))))
                    };
                    if (($has_otherwise && $otherwise_block->has_my_decl())) {
                        ($otherwise_block = Return->new(('result' => Do->new(('block' => ($last_statement->otherwise()))))))
                    };
                    ($s2 = (Ruby::tab($level) . 'if ' . Ruby::to_bool(' ' . chr(38) . chr(38) . ' ', do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $cond );
    $List_a
}) . (chr(10)) . $body_block->emit_ruby_indented(($level + 1))));
                    if (($has_otherwise)) {
                        ($s2 = ($s2 . (chr(10)) . Ruby::tab($level) . ('else' . chr(10)) . $otherwise_block->emit_ruby_indented(($level + 1)) . (chr(10)) . Ruby::tab($level) . ('end')))
                    }
                    else {
                        ($s2 = ($s2 . (chr(10)) . Ruby::tab($level) . ('end')))
                    }
                }
                else {
                    if (Main::isa($last_statement, 'Bind')) {
                        ($s2 = $last_statement->emit_ruby_indented($level));
                        ($s2 = ($s2 . (chr(10)) . Ruby::tab($level) . ('return ') . ($last_statement->parameters())->emit_ruby()))
                    }
                    else {
                        if ((Main::isa($last_statement, 'Return') || Main::isa($last_statement, 'For'))) {
                            ($s2 = $last_statement->emit_ruby_indented($level))
                        }
                        else {
                            ($s2 = (Ruby::tab($level) . ('return ') . $last_statement->emit_ruby()))
                        }
                    }
                };
                for my $stmt ( @{$List_anon_block} ) {
                    push( @{$List_s}, $stmt->emit_ruby_indented($level) )
                };
                push( @{$List_s}, $s2 )
            };
            if ($has_my_decl) {
                ($level = ($level - 1));
                push( @{$List_s}, (Ruby::tab($level) . (chr(125) . '.call(') . Main::join($List_my_init, (', ')) . (')')) )
            };
            ($List_anon_block = $List_tmp);
            return scalar (Main::join($List_s, (chr(10))))
        }
    }

;
    {
    package CompUnit;
        sub new { shift; bless { @_ }, "CompUnit" }
        sub name { $_[0]->{name} };
        sub attributes { $_[0]->{attributes} };
        sub methods { $_[0]->{methods} };
        sub body { $_[0]->{body} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (my  $List_s = bless [], 'ARRAY');
            ((my  $block) = Perlito::Ruby::LexicalBlock->new(('block' => $self->{body})));
            ((my  $name) = Main::to_go_namespace($self->{name}));
            for my $decl ( @{$self->{body}} ) {
                if (Main::isa($decl, 'Use')) {
                    if (($decl->mod() eq 'v6')) {

                    }
                    else {
                        push( @{$List_s}, (Ruby::tab($level) . ('require ' . chr(39)) . Main::to_go_namespace($decl->mod()) . ('.rb' . chr(39))) )
                    }
                }
            };
            push( @{$List_s}, (Ruby::tab($level) . 'class C_' . $name) );
            push( @{$List_s}, (Ruby::tab(($level + 1)) . chr(36) . $name . ' ' . chr(61) . ' C_' . $name . '.new()') );
            push( @{$List_s}, (Ruby::tab(($level + 1)) . 'namespace ' . chr(61) . ' ' . chr(36) . $name) );
            push( @{$List_s}, $block->emit_ruby_indented(($level + 1)) );
            push( @{$List_s}, (Ruby::tab($level) . ('end')) );
            return scalar (Main::join($List_s, (chr(10))))
        }
    }

;
    {
    package Val::Int;
        sub new { shift; bless { @_ }, "Val::Int" }
        sub int { $_[0]->{int} };
        sub emit_ruby {
            my $self = $_[0];
            $self->{int}
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Ruby::tab($level) . $self->{int})
        }
    }

;
    {
    package Val::Bit;
        sub new { shift; bless { @_ }, "Val::Bit" }
        sub bit { $_[0]->{bit} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Ruby::tab($level) . (($self->{bit} ? 'true' : 'false')))
        }
    }

;
    {
    package Val::Num;
        sub new { shift; bless { @_ }, "Val::Num" }
        sub num { $_[0]->{num} };
        sub emit_ruby {
            my $self = $_[0];
            $self->{num}
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Ruby::tab($level) . $self->{num})
        }
    }

;
    {
    package Val::Buf;
        sub new { shift; bless { @_ }, "Val::Buf" }
        sub buf { $_[0]->{buf} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Ruby::tab($level) . chr(34) . $self->{buf} . chr(34))
        }
    }

;
    {
    package Val::Undef;
        sub new { shift; bless { @_ }, "Val::Undef" }
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Ruby::tab($level) . 'nil')
        }
    }

;
    {
    package Val::Object;
        sub new { shift; bless { @_ }, "Val::Object" }
        sub class { $_[0]->{class} };
        sub fields { $_[0]->{fields} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Ruby::tab($level) . $self->{class}->emit_ruby() . '(' . $self->{fields}->emit_ruby() . ')')
        }
    }

;
    {
    package Lit::Array;
        sub new { shift; bless { @_ }, "Lit::Array" }
        sub array1 { $_[0]->{array1} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $ast) = $self->expand_interpolation());
            return scalar ($ast->emit_ruby_indented($level))
        }
    }

;
    {
    package Lit::Hash;
        sub new { shift; bless { @_ }, "Lit::Hash" }
        sub hash1 { $_[0]->{hash1} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $ast) = $self->expand_interpolation());
            return scalar ($ast->emit_ruby_indented($level))
        }
    }

;
    {
    package Lit::Code;
        sub new { shift; bless { @_ }, "Lit::Code" }
        1
    }

;
    {
    package Lit::Object;
        sub new { shift; bless { @_ }, "Lit::Object" }
        sub class { $_[0]->{class} };
        sub fields { $_[0]->{fields} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $fields) = $self->{fields});
            (my  $List_str = bless [], 'ARRAY');
            for my $field ( @{($fields)} ) {
                push( @{$List_str}, ('o.v_' . ($field->[0])->buf() . chr(61) . ($field->[1])->emit_ruby() . (chr(59) . ' ')) )
            };
            (Ruby::tab($level) . ('Proc.new ' . chr(123) . ' ' . chr(124) . 'o' . chr(124) . ' ') . Main::join($List_str, ' ') . ('o ' . chr(125) . '.call(C_') . Main::to_go_namespace($self->{class}) . ('.new)'))
        }
    }

;
    {
    package Index;
        sub new { shift; bless { @_ }, "Index" }
        sub obj { $_[0]->{obj} };
        sub index_exp { $_[0]->{index_exp} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Ruby::tab($level) . $self->{obj}->emit_ruby() . '[' . $self->{index_exp}->emit_ruby() . ']')
        }
    }

;
    {
    package Lookup;
        sub new { shift; bless { @_ }, "Lookup" }
        sub obj { $_[0]->{obj} };
        sub index_exp { $_[0]->{index_exp} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Ruby::tab($level) . $self->{obj}->emit_ruby() . '[' . $self->{index_exp}->emit_ruby() . ']')
        }
    }

;
    {
    package Var;
        sub new { shift; bless { @_ }, "Var" }
        sub sigil { $_[0]->{sigil} };
        sub twigil { $_[0]->{twigil} };
        sub name { $_[0]->{name} };
        ((my  $table) = do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{chr(36)} = 'v_');
    ($Hash_a->{chr(64)} = 'list_');
    ($Hash_a->{chr(37)} = 'hash_');
    ($Hash_a->{chr(38)} = 'code_');
    $Hash_a
});
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            if ((((($self->{sigil} eq chr(64))) && (($self->{twigil} eq '*'))) && (($self->{name} eq 'ARGS')))) {
                return scalar ((Ruby::tab($level) . 'ARGV'))
            };
            return scalar ((Ruby::tab($level) . (((($self->{twigil} eq '.')) ? (('self.v_' . $self->{name} . '')) : (((($self->{name} eq chr(47))) ? (($table->{$self->{sigil}} . 'MATCH')) : (($table->{$self->{sigil}} . $self->{name} . ''))))))))
        };
        sub emit_ruby_name {
            my $self = $_[0];
            return scalar ((((($self->{twigil} eq '.')) ? (('self.v_' . $self->{name})) : (((($self->{name} eq chr(47))) ? (($table->{$self->{sigil}} . 'MATCH')) : (($table->{$self->{sigil}} . $self->{name})))))))
        }
    }

;
    {
    package Proto;
        sub new { shift; bless { @_ }, "Proto" }
        sub name { $_[0]->{name} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Ruby::tab($level) . chr(36) . Main::to_go_namespace($self->{name}))
        }
    }

;
    {
    package Call;
        sub new { shift; bless { @_ }, "Call" }
        sub invocant { $_[0]->{invocant} };
        sub hyper { $_[0]->{hyper} };
        sub method { $_[0]->{method} };
        sub arguments { $_[0]->{arguments} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $invocant) = $self->{invocant}->emit_ruby());
            if (((((($self->{method} eq 'perl')) || (($self->{method} eq 'yaml'))) || (($self->{method} eq 'say'))) || (($self->{method} eq 'isa')))) {
                if (($self->{hyper})) {
                    return scalar (($invocant . ('.map ' . chr(123) . chr(124) . 'x' . chr(124) . ' x.') . $self->{method} . ('(') . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ', ') . (')' . chr(125))))
                }
                else {
                    return scalar (('mp6_' . $self->{method} . '(' . Main::join(([ map { $_->emit_ruby() } @{( do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $self->{invocant} );
    ($List_v = $self->{arguments});
    for my $x ( @{(bless [0 .. ((scalar( @{$List_v} ) - 1))], 'ARRAY')} ) {
        push( @{$List_a}, $List_v->[$x] )
    };
    $List_a
} )} ]), ', ') . ')'))
                }
            };
            ((my  $meth) = $self->{method});
            if (($meth eq 'postcircumfix:<( )>')) {
                return scalar ((Ruby::tab($level) . $invocant . '.call(' . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            if (((((((($meth eq 'values')) || (($meth eq 'keys'))) || (($meth eq 'push'))) || (($meth eq 'shift'))) || (($meth eq 'concat'))) || (($meth eq 'join')))) {
                return scalar ((Ruby::tab($level) . $invocant . '.' . $meth . '(' . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            if (($meth eq 'chars')) {
                return scalar ((Ruby::tab($level) . '' . $invocant . ('.length')))
            };
            ((my  $call) = ('f_' . $meth . '(' . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ', ') . ')'));
            if (($self->{hyper})) {
                (Ruby::tab($level) . $invocant . ('.map ' . chr(123) . chr(124) . 'x' . chr(124) . ' x.') . $call . (chr(125)))
            }
            else {
                (Ruby::tab($level) . $invocant . '.' . $call)
            }
        }
    }

;
    {
    package Apply;
        sub new { shift; bless { @_ }, "Apply" }
        sub code { $_[0]->{code} };
        sub arguments { $_[0]->{arguments} };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Ruby::tab($level) . $self->emit_ruby())
        };
        sub emit_ruby {
            my $self = $_[0];
            ((my  $code) = $self->{code});
            if (Main::isa($code, 'Str')) {

            }
            else {
                return scalar (('(' . $self->{code}->emit_ruby() . ').(' . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            if (($code eq 'self')) {
                return scalar ('self')
            };
            if (($code eq 'make')) {
                return scalar (('v_MATCH.v_capture ' . chr(61) . ' ' . ($self->{arguments}->[0])->emit_ruby() . ''))
            };
            if (($code eq 'False')) {
                return scalar ('false')
            };
            if (($code eq 'True')) {
                return scalar ('true')
            };
            if (($code eq 'say')) {
                return scalar (('puts' . Ruby::to_str(' + ', $self->{arguments})))
            };
            if (($code eq 'print')) {
                return scalar (('print' . Ruby::to_str(' + ', $self->{arguments})))
            };
            if (($code eq 'warn')) {
                return scalar ((chr(36) . 'stdout.puts(' . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            if (($code eq 'array')) {
                return scalar (('[' . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ' ') . ']'))
            };
            if (($code eq 'Int')) {
                return scalar (('(' . ($self->{arguments}->[0])->emit_ruby() . ').to_i'))
            };
            if (($code eq 'Num')) {
                return scalar (('(' . ($self->{arguments}->[0])->emit_ruby() . ').to_f'))
            };
            if (($code eq 'prefix:<' . chr(126) . '>')) {
                return scalar (Ruby::to_str(' + ', $self->{arguments}))
            };
            if (($code eq 'prefix:<' . chr(33) . '>')) {
                return scalar ((chr(33) . Ruby::to_bool(' ' . chr(38) . chr(38) . ' ', $self->{arguments})))
            };
            if (($code eq 'prefix:<' . chr(63) . '>')) {
                return scalar ((chr(33) . '(' . chr(33) . Ruby::to_bool(' ' . chr(38) . chr(38) . ' ', $self->{arguments}) . ')'))
            };
            if (($code eq 'prefix:<' . chr(36) . '>')) {
                return scalar (('mp6_to_scalar(' . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ' ') . ')'))
            };
            if (($code eq 'prefix:<' . chr(64) . '>')) {
                return scalar (('(' . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ' ') . ')'))
            };
            if (($code eq 'prefix:<' . chr(37) . '>')) {
                return scalar ((chr(37) . chr(123) . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ' ') . chr(125)))
            };
            if (($code eq 'list:<' . chr(126) . '>')) {
                return scalar (Ruby::to_str(' + ', $self->{arguments}))
            };
            if (($code eq 'infix:<+>')) {
                return scalar (Ruby::to_num(' + ', $self->{arguments}))
            };
            if (($code eq 'infix:<->')) {
                return scalar (Ruby::to_num(' - ', $self->{arguments}))
            };
            if (($code eq 'infix:<*>')) {
                return scalar (Ruby::to_num(' * ', $self->{arguments}))
            };
            if (($code eq 'infix:<' . chr(47) . '>')) {
                return scalar (Ruby::to_num(' ' . chr(47) . ' ', $self->{arguments}))
            };
            if (($code eq 'infix:<' . chr(38) . chr(38) . '>')) {
                return scalar (Ruby::to_bool(' ' . chr(38) . chr(38) . ' ', $self->{arguments}))
            };
            if (($code eq 'infix:<' . chr(124) . chr(124) . '>')) {
                return scalar (Ruby::to_bool(' ' . chr(124) . chr(124) . ' ', $self->{arguments}))
            };
            if (($code eq 'infix:<eq>')) {
                return scalar (Ruby::to_str(' ' . chr(61) . chr(61) . ' ', $self->{arguments}))
            };
            if (($code eq 'infix:<ne>')) {
                return scalar (Ruby::to_str(' ' . chr(33) . chr(61) . ' ', $self->{arguments}))
            };
            if (($code eq 'infix:<' . chr(61) . chr(61) . '>')) {
                return scalar (Ruby::to_num(' ' . chr(61) . chr(61) . ' ', $self->{arguments}))
            };
            if (($code eq 'infix:<' . chr(33) . chr(61) . '>')) {
                return scalar (Ruby::to_num(' ' . chr(33) . chr(61) . ' ', $self->{arguments}))
            };
            if (($code eq 'infix:<<>')) {
                return scalar (Ruby::to_num(' < ', $self->{arguments}))
            };
            if (($code eq 'infix:<>>')) {
                return scalar (Ruby::to_num(' > ', $self->{arguments}))
            };
            if (($code eq 'exists')) {
                ((my  $arg) = $self->{arguments}->[0]);
                if (Main::isa($arg, 'Lookup')) {
                    return scalar (('(' . ($arg->obj())->emit_ruby() . ').has_key' . chr(63) . '(' . ($arg->index_exp())->emit_ruby() . ')'))
                }
            };
            if (($code eq 'ternary:<' . chr(63) . chr(63) . ' ' . chr(33) . chr(33) . '>')) {
                return scalar (('(' . Ruby::to_bool(' ' . chr(38) . chr(38) . ' ', do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $self->{arguments}->[0] );
    $List_a
}) . ' ' . chr(63) . ' ' . ($self->{arguments}->[1])->emit_ruby() . ' : ' . ($self->{arguments}->[2])->emit_ruby() . ')'))
            };
            if (($code eq 'circumfix:<( )>')) {
                return scalar (('(' . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            if (($code eq 'infix:<' . chr(61) . '>')) {
                return scalar (emit_ruby_bind($self->{arguments}->[0], $self->{arguments}->[1]))
            };
            if (($code eq 'substr')) {
                return scalar ((Ruby::to_str(' + ', do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $self->{arguments}->[0] );
    $List_a
}) . '[' . ($self->{arguments}->[1])->emit_ruby() . ', ' . ($self->{arguments}->[2])->emit_ruby() . ']'))
            };
            if (($code eq 'index')) {
                return scalar (('(' . ($self->{arguments}->[0])->emit_ruby() . ').index(' . ($self->{arguments}->[1])->emit_ruby() . ')'))
            };
            if (($code eq 'defined')) {
                return scalar (('(' . ($self->{arguments}->[0])->emit_ruby() . ' ' . chr(33) . chr(61) . ' nil)'))
            };
            if (($code eq 'shift')) {
                return scalar ((($self->{arguments}->[0])->emit_ruby() . '.shift()'))
            };
            if (($code eq 'pop')) {
                return scalar ((($self->{arguments}->[0])->emit_ruby() . '.pop()'))
            };
            if (($code eq 'push')) {
                return scalar ((($self->{arguments}->[0])->emit_ruby() . '.push(' . ($self->{arguments}->[1])->emit_ruby() . ')'))
            };
            if (($code eq 'unshift')) {
                return scalar ((($self->{arguments}->[0])->emit_ruby() . '.unshift(' . ($self->{arguments}->[1])->emit_ruby() . ')'))
            };
            if ($self->{namespace}) {
                return scalar ((chr(36) . Main::to_go_namespace($self->{namespace}) . '.f_' . $self->{code} . '(' . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            ('namespace.f_' . $self->{code} . '(' . Main::join(([ map { $_->emit_ruby() } @{( $self->{arguments} )} ]), ', ') . ')')
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Ruby::tab($level) . $self->emit_ruby())
        };
        sub emit_ruby_bind {
            my $parameters = $_[0];
            my $arguments = $_[1];
            if (Main::isa($parameters, 'Index')) {
                return scalar ((($parameters->obj())->emit_ruby() . '[' . ($parameters->index_exp())->emit_ruby() . '] ' . chr(61) . ' ' . $arguments->emit_ruby()))
            };
            if (Main::isa($parameters, 'Lookup')) {
                return scalar ((($parameters->obj())->emit_ruby() . '[' . ($parameters->index_exp())->emit_ruby() . '] ' . chr(61) . ' ' . $arguments->emit_ruby()))
            };
            if (Main::isa($parameters, 'Call')) {
                return scalar ((($parameters->invocant())->emit_ruby() . ('.v_') . $parameters->method() . (' ' . chr(61) . ' ') . $arguments->emit_ruby() . ''))
            };
            return scalar (($parameters->emit_ruby() . ' ' . chr(61) . ' ' . $arguments->emit_ruby()))
        }
    }

;
    {
    package Return;
        sub new { shift; bless { @_ }, "Return" }
        sub result { $_[0]->{result} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Ruby::tab($level) . 'return ' . $self->{result}->emit_ruby() . '')
        }
    }

;
    {
    package If;
        sub new { shift; bless { @_ }, "If" }
        sub cond { $_[0]->{cond} };
        sub body { $_[0]->{body} };
        sub otherwise { $_[0]->{otherwise} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $has_body) = ($self->{body} ? 1 : 0));
            ((my  $has_otherwise) = ($self->{otherwise} ? 1 : 0));
            ((my  $body_block) = Perlito::Ruby::LexicalBlock->new(('block' => $self->{body}->stmts())));
            if ($body_block->has_my_decl()) {
                ($body_block = Do->new(('block' => $self->{body})))
            };
            ((my  $s) = (Ruby::tab($level) . 'if ' . Ruby::to_bool(' ' . chr(38) . chr(38) . ' ', do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $self->{cond} );
    $List_a
}) . (chr(10)) . $body_block->emit_ruby_indented(($level + 1))));
            if (($has_otherwise)) {
                ((my  $otherwise_block) = Perlito::Ruby::LexicalBlock->new(('block' => $self->{otherwise}->stmts())));
                if ($otherwise_block->has_my_decl()) {
                    ($otherwise_block = Do->new(('block' => $self->{otherwise})))
                };
                ($s = ($s . (chr(10) . Ruby::tab($level) . ('else' . chr(10)) . $otherwise_block->emit_ruby_indented(($level + 1)))))
            };
            ($s = ($s . (chr(10) . Ruby::tab($level) . ('end'))));
            return scalar ($s)
        }
    }

;
    {
    package While;
        sub new { shift; bless { @_ }, "While" }
        sub init { $_[0]->{init} };
        sub cond { $_[0]->{cond} };
        sub continue { $_[0]->{continue} };
        sub body { $_[0]->{body} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $body_block) = Perlito::Ruby::LexicalBlock->new(('block' => $self->{body})));
            if ($body_block->has_my_decl()) {
                ($body_block = Do->new(('block' => $self->{body})))
            };
            if (($self->{init} && $self->{continue})) {
                die(('not implemented (While)'))
            };
            (Ruby::tab($level) . 'while ' . Ruby::to_bool(' ' . chr(38) . chr(38) . ' ', do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $self->{cond} );
    $List_a
}) . (chr(10)) . $body_block->emit_ruby_indented(($level + 1)) . (chr(10)) . Ruby::tab($level) . 'end')
        }
    }

;
    {
    package For;
        sub new { shift; bless { @_ }, "For" }
        sub cond { $_[0]->{cond} };
        sub body { $_[0]->{body} };
        sub topic { $_[0]->{topic} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $body_block) = Perlito::Ruby::LexicalBlock->new(('block' => $self->{body})));
            (Ruby::tab($level) . 'for ' . $self->{topic}->emit_ruby_name() . (' in ') . $self->{cond}->emit_ruby() . (chr(10)) . $body_block->emit_ruby_indented(($level + 1)) . (chr(10)) . Ruby::tab($level) . 'end')
        }
    }

;
    {
    package Decl;
        sub new { shift; bless { @_ }, "Decl" }
        sub decl { $_[0]->{decl} };
        sub type { $_[0]->{type} };
        sub var { $_[0]->{var} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $decl) = $self->{decl});
            ((my  $name) = $self->{var}->name());
            (Ruby::tab($level) . (((($decl eq 'has')) ? ('') : $self->{var}->emit_ruby())))
        };
        sub emit_ruby_init {
            my $self = $_[0];
            if ((($self->{var})->sigil() eq chr(37))) {
                return scalar (chr(123) . chr(125))
            }
            else {
                if ((($self->{var})->sigil() eq chr(64))) {
                    return scalar ('[]')
                }
                else {
                    return scalar ('nil')
                }
            };
            return scalar ('')
        }
    }

;
    {
    package Sig;
        sub new { shift; bless { @_ }, "Sig" }
        sub invocant { $_[0]->{invocant} };
        sub positional { $_[0]->{positional} };
        sub named { $_[0]->{named} };
        sub emit_ruby {
            my $self = $_[0];
            ' print ' . chr(39) . 'Signature - TODO' . chr(39) . chr(59) . ' die ' . chr(39) . 'Signature - TODO' . chr(39) . chr(59) . ' '
        }
    }

;
    {
    package Method;
        sub new { shift; bless { @_ }, "Method" }
        sub name { $_[0]->{name} };
        sub sig { $_[0]->{sig} };
        sub block { $_[0]->{block} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $sig) = $self->{sig});
            ((my  $invocant) = $sig->invocant());
            ((my  $pos) = $sig->positional());
            ((my  $args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            ((my  $default_args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            ((my  $meth_args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            for my $field ( @{($pos)} ) {
                ((my  $arg) = $field->emit_ruby_name());
                push( @{$args}, $arg );
                push( @{$default_args}, ($arg . chr(61) . 'nil') );
                push( @{$meth_args}, ($arg . chr(61) . 'nil') )
            };
            ((my  $block) = Perlito::Ruby::LexicalBlock->new(('block' => $self->{block}), ('needs_return' => 1)));
            (my  $List_s = bless [], 'ARRAY');
            push( @{$List_s}, (Ruby::tab($level) . 'send( :define_method, ' . chr(34) . 'f_' . $self->{name} . chr(34) . '.to_sym, lambda' . chr(92) . chr(123) . ' ' . chr(124) . Main::join($default_args, (', ')) . chr(124)) );
            push( @{$List_s}, (Ruby::tab(($level + 1)) . $invocant->emit_ruby_name() . (' ' . chr(61) . ' self')) );
            push( @{$List_s}, $block->emit_ruby_indented(($level + 1)) );
            push( @{$List_s}, (Ruby::tab($level) . (chr(125) . ' )')) );
            return scalar (Main::join($List_s, (chr(10))))
        }
    }

;
    {
    package Sub;
        sub new { shift; bless { @_ }, "Sub" }
        sub name { $_[0]->{name} };
        sub sig { $_[0]->{sig} };
        sub block { $_[0]->{block} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $label) = ('_anon_' . Perlito::Ruby::LexicalBlock::get_ident_ruby()));
            if ((($self->{name} eq ''))) {
                Perlito::Ruby::LexicalBlock::push_stmt_ruby(Perlito::Ruby::AnonSub->new(('name' => $label), ('block' => $self->{block}), ('sig' => $self->{sig}), ('handles_return_exception' => 1)));
                return scalar ((Ruby::tab($level) . 'f_' . $label))
            };
            ((my  $sig) = $self->{sig});
            ((my  $pos) = $sig->positional());
            ((my  $args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            ((my  $default_args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            ((my  $meth_args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'self' );
    $List_a
});
            for my $field ( @{($pos)} ) {
                ((my  $arg) = $field->emit_ruby_name());
                push( @{$args}, $arg );
                push( @{$default_args}, ($arg . chr(61) . 'nil') );
                push( @{$meth_args}, ($arg . chr(61) . 'nil') )
            };
            ((my  $block) = Perlito::Ruby::LexicalBlock->new(('block' => $self->{block}), ('needs_return' => 1)));
            ((my  $label2) = ('_anon_' . Perlito::Ruby::LexicalBlock::get_ident_ruby()));
            (my  $List_s = bless [], 'ARRAY');
            push( @{$List_s}, (Ruby::tab($level) . 'send( :define_method, ' . chr(34) . 'f_' . $self->{name} . chr(34) . '.to_sym, lambda' . chr(123) . ' ' . chr(124) . Main::join($default_args, (', ')) . chr(124)) );
            push( @{$List_s}, $block->emit_ruby_indented(($level + 1)) );
            push( @{$List_s}, (Ruby::tab($level) . (chr(125) . ' )')) );
            return scalar (Main::join($List_s, (chr(10))))
        }
    }

;
    {
    package Do;
        sub new { shift; bless { @_ }, "Do" }
        sub block { $_[0]->{block} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            (my  $List_s = bless [], 'ARRAY');
            push( @{$List_s}, (Ruby::tab($level) . ('Proc.new' . chr(123) . ' ' . chr(124) . chr(124) . ' ')) );
            push( @{$List_s}, (Perlito::Ruby::LexicalBlock->new(('block' => $self->{block}), ('needs_return' => 0)))->emit_ruby_indented(($level + 1)) );
            push( @{$List_s}, (Ruby::tab($level) . (chr(125) . '.call()')) );
            return scalar (Main::join($List_s, (chr(10))))
        }
    }

;
    {
    package Use;
        sub new { shift; bless { @_ }, "Use" }
        sub mod { $_[0]->{mod} };
        sub emit_ruby {
            my $self = $_[0];
            $self->emit_ruby_indented(0)
        };
        sub emit_ruby_indented {
            my $self = $_[0];
            my $level = $_[1];
            return scalar ('')
        }
    }


}

1;
