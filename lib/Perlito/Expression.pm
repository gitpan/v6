# Do not edit this file - Generated by Perlito 7.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito::Perl5::Runtime;
use Perlito::Perl5::Prelude;
our $MATCH = Perlito::Match->new();
{
package GLOBAL;
    sub new { shift; bless { @_ }, "GLOBAL" }
    {
    package Perlito::Expression;
        sub new { shift; bless { @_ }, "Perlito::Expression" }
        use Perlito::Precedence;
        use Perlito::Grammar;
        use Perlito::Perl5::Emitter;
        sub expand_list {
            my $param_list = $_[0];
            if (((Main::isa($param_list, 'Apply')) && ((($param_list->code()) eq 'list:<,>')))) {
                ((my  $args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
                for my $v ( @{(($param_list->arguments()))} ) {
                    if (defined($v)) {
                        push( @{$args}, $v )
                    }
                };
                return scalar ($args)
            }
            else {
                if (($param_list eq '*undef*')) {
                    return scalar (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
})
                }
                else {
                    return scalar (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $param_list );
    $List_a
})
                }
            }
        };
        sub block_or_hash {
            my $o = $_[0];
            if (defined($o->sig())) {
                return scalar ($o)
            };
            ((my  $stmts) = $o->stmts());
            if (((!((defined($stmts)))) || (((scalar( @{$stmts} )) == 0)))) {
                return scalar (Lit::Hash->new(('hash1' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
})))
            };
            if (((scalar( @{$stmts} )) != 1)) {
                return scalar ($o)
            };
            ((my  $stmt) = $stmts->[0]);
            if (!((Main::isa($stmt, 'Apply')))) {
                return scalar ($o)
            };
            if ((($stmt->code()) eq 'infix:<' . chr(61) . '>>')) {
                return scalar (Lit::Hash->new(('hash1' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $stmt );
    $List_a
})))
            };
            if ((($stmt->code()) ne 'list:<,>')) {
                return scalar ($o)
            };
            for my $item ( @{(($stmt->arguments()))} ) {
                if ((Main::isa($item, 'Apply') && (($item->code()) eq 'infix:<' . chr(61) . '>>'))) {
                    return scalar (Lit::Hash->new(('hash1' => expand_list($stmt))))
                }
            };
            return scalar ($o)
        };
        sub pop_term {
            my $num_stack = $_[0];
            ((my  $v) = pop( @{$num_stack} ));
            if (Main::isa($v, 'Array')) {
                if (($v->[1] eq 'methcall_no_params')) {
                    ($v = Call->new(('invocant' => undef()), ('method' => $v->[2]), ('hyper' => $v->[3])));
                    return scalar ($v)
                };
                if (($v->[1] eq 'funcall_no_params')) {
                    ($v = Apply->new(('code' => $v->[3]), ('namespace' => $v->[2])));
                    return scalar ($v)
                };
                if (($v->[1] eq 'methcall')) {
                    if (($v->[3])->{'end_block'}) {
                        unshift( @{$num_stack}, ($v->[3])->{'end_block'} )
                    };
                    ((my  $param_list) = expand_list(($v->[3])->{'exp'}));
                    ($v = Call->new(('invocant' => undef()), ('method' => $v->[2]), ('arguments' => $param_list), ('hyper' => $v->[4])));
                    return scalar ($v)
                };
                if (($v->[1] eq 'funcall')) {
                    if (($v->[4])->{'end_block'}) {
                        unshift( @{$num_stack}, ($v->[4])->{'end_block'} )
                    };
                    ((my  $param_list) = expand_list(($v->[4])->{'exp'}));
                    ($v = Apply->new(('code' => $v->[3]), ('arguments' => $param_list), ('namespace' => $v->[2])));
                    return scalar ($v)
                };
                if (($v->[1] eq '( )')) {
                    ((my  $param_list) = expand_list($v->[2]));
                    ($v = Apply->new(('code' => 'circumfix:<( )>'), ('arguments' => $param_list), ('namespace' => '')));
                    return scalar ($v)
                };
                if (($v->[1] eq '[ ]')) {
                    ((my  $param_list) = expand_list($v->[2]));
                    ($v = Lit::Array->new(('array1' => $param_list)));
                    return scalar ($v)
                };
                if (($v->[1] eq 'block')) {
                    ($v = Lit::Block->new(('stmts' => $v->[2]), ('sig' => $v->[3])));
                    ($v = block_or_hash($v));
                    return scalar ($v)
                };
                if (($v->[1] eq '.( )')) {
                    ($v = Call->new(('invocant' => undef()), ('method' => 'postcircumfix:<( )>'), ('arguments' => $v->[2]), ('hyper' => 0)));
                    return scalar ($v)
                };
                if (($v->[1] eq '.[ ]')) {
                    ($v = Index->new(('obj' => undef()), ('index_exp' => $v->[2])));
                    return scalar ($v)
                };
                if (($v->[1] eq '.' . chr(123) . ' ' . chr(125))) {
                    ($v = Lookup->new(('obj' => undef()), ('index_exp' => $v->[2])));
                    return scalar ($v)
                };
                if ((Main::isa(($v->[1]), 'Array') && (((scalar( @{($v->[1])} )) == 2)))) {
                    ($v = Apply->new(('code' => 'pair'), ('arguments' => $v->[1]), ('namespace' => '')));
                    return scalar ($v)
                };
                return scalar ($v->[1])
            };
            return scalar ($v)
        };
        sub reduce_postfix {
            my $op = $_[0];
            my $value = $_[1];
            ((my  $v) = $op);
            if (($v->[1] eq 'methcall_no_params')) {
                ($v = Call->new(('invocant' => $value), ('method' => $v->[2]), ('hyper' => $v->[3])));
                return scalar ($v)
            };
            if (($v->[1] eq 'funcall_no_params')) {
                die(('unexpected function call'));
                push( @{$v}, $value );
                return scalar ($v)
            };
            if (($v->[1] eq 'methcall')) {
                ((my  $param_list) = expand_list(($v->[3])->{'exp'}));
                ($v = Call->new(('invocant' => $value), ('method' => $v->[2]), ('arguments' => $param_list), ('hyper' => $v->[4])));
                return scalar ($v)
            };
            if (($v->[1] eq 'funcall')) {
                die(('unexpected function call'));
                push( @{$v}, $value );
                return scalar ($v)
            };
            if (($v->[1] eq '( )')) {
                ((my  $param_list) = expand_list($v->[2]));
                if ((Main::isa($value, 'Apply') && !((defined($value->arguments()))))) {
                    (($value)->{arguments} = $param_list);
                    return scalar ($value)
                };
                if ((Main::isa($value, 'Call') && !((defined($value->arguments()))))) {
                    (($value)->{arguments} = $param_list);
                    return scalar ($value)
                };
                ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:<( )>'), ('arguments' => $param_list), ('hyper' => 0)));
                return scalar ($v)
            };
            if (($v->[1] eq '[ ]')) {
                ($v = Index->new(('obj' => $value), ('index_exp' => $v->[2])));
                return scalar ($v)
            };
            if (($v->[1] eq 'block')) {
                ($v = Lookup->new(('obj' => $value), ('index_exp' => ($v->[2])->[0])));
                return scalar ($v)
            };
            if (($v->[1] eq '.( )')) {
                ((my  $param_list) = expand_list($v->[2]));
                ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:<( )>'), ('arguments' => $param_list), ('hyper' => 0)));
                return scalar ($v)
            };
            if (($v->[1] eq '.[ ]')) {
                ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:<[ ]>'), ('arguments' => $v->[2]), ('hyper' => 0)));
                return scalar ($v)
            };
            if (($v->[1] eq '.' . chr(123) . ' ' . chr(125))) {
                ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:<' . chr(123) . ' ' . chr(125) . '>'), ('arguments' => $v->[2]), ('hyper' => 0)));
                return scalar ($v)
            };
            push( @{$op}, $value );
            return scalar ($op)
        };
        ((my  $reduce_to_ast) = sub  {
    my $op_stack = $_[0];
    my $num_stack = $_[1];
    ((my  $last_op) = shift( @{$op_stack} ));
    if (($last_op->[0] eq 'prefix')) {
        push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('prefix:<' . $last_op->[1] . '>')), ('arguments' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, pop_term($num_stack) );
    $List_a
})) )
    }
    else {
        if (($last_op->[0] eq 'postfix')) {
            push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('postfix:<' . $last_op->[1] . '>')), ('arguments' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, pop_term($num_stack) );
    $List_a
})) )
        }
        else {
            if (($last_op->[0] eq 'postfix_or_term')) {
                push( @{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)) )
            }
            else {
                if (Perlito::Precedence::is_assoc_type('list', $last_op->[1])) {
                    (my  $arg);
                    if ((scalar( @{$num_stack} ) < 2)) {
                        ((my  $v2) = pop_term($num_stack));
                        if (((Main::isa($v2, 'Apply')) && (($v2->code() eq (('list:<' . $last_op->[1] . '>')))))) {
                            push( @{($v2->arguments())}, undef() );
                            push( @{$num_stack}, $v2 )
                        }
                        else {
                            push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('list:<' . $last_op->[1] . '>')), ('arguments' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $v2 );
    push( @{$List_a}, undef() );
    $List_a
})) )
                        };
                        return ()
                    }
                    else {
                        ((my  $v2) = pop_term($num_stack));
                        ($arg = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, pop_term($num_stack) );
    push( @{$List_a}, $v2 );
    $List_a
})
                    };
                    if ((((Main::isa(($arg->[0]), 'Apply')) && (($last_op->[0] eq 'infix'))) && ((($arg->[0])->code() eq (('list:<' . $last_op->[1] . '>')))))) {
                        push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => ($arg->[0])->code()), ('arguments' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    ($List_v = ((($arg->[0])->arguments())));
    for my $x ( @{(bless [0 .. ((scalar( @{$List_v} ) - 1))], 'ARRAY')} ) {
        push( @{$List_a}, $List_v->[$x] )
    };
    push( @{$List_a}, $arg->[1] );
    $List_a
})) );
                        return ()
                    };
                    push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('list:<' . $last_op->[1] . '>')), ('arguments' => $arg)) )
                }
                else {
                    if (Perlito::Precedence::is_assoc_type('chain', $last_op->[1])) {
                        if ((scalar( @{$num_stack} ) < 2)) {
                            die(('Missing value after operator ' . $last_op->[1]))
                        };
                        ((my  $v2) = pop_term($num_stack));
                        ((my  $arg) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, pop_term($num_stack) );
    push( @{$List_a}, $v2 );
    $List_a
});
                        push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('infix:<' . $last_op->[1] . '>')), ('arguments' => $arg)) )
                    }
                    else {
                        if (($last_op->[0] eq 'ternary')) {
                            if (((scalar( @{$num_stack} ) < 2))) {
                                die(('Missing value after ternary operator'))
                            };
                            ((my  $v2) = pop_term($num_stack));
                            push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('ternary:<' . $last_op->[1] . '>')), ('arguments' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, pop_term($num_stack) );
    push( @{$List_a}, $last_op->[2] );
    push( @{$List_a}, $v2 );
    $List_a
})) )
                        }
                        else {
                            if (((scalar( @{$num_stack} ) < 2))) {
                                die(('missing value after operator ' . chr(39) . $last_op->[1] . (chr(39))))
                            };
                            ((my  $v2) = pop_term($num_stack));
                            push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => ('infix:<' . $last_op->[1] . '>')), ('arguments' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, pop_term($num_stack) );
    push( @{$List_a}, $v2 );
    $List_a
})) )
                        }
                    }
                }
            }
        }
    }
});
        sub capture_name {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    (do {
    ((do {
    ((my  $m2) = Perlito::Grammar->full_ident($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $last_pos) = $MATCH->to());
    if (!((do {
    ((my  $pos1) = $MATCH->to());
    (do {
    (((('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $m2) = Perlito::Grammar->ident($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        if (exists($MATCH->{'Perlito::Grammar.ident'})) {
            push( @{($MATCH->{'Perlito::Grammar.ident'})}, $m2 )
        }
        else {
            ($MATCH->{'Perlito::Grammar.ident'} = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $m2 );
    $List_a
})
        };
        1
    }
    else {
        0
    }
}))
})
}))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))
})
})));
            $MATCH
        };
        sub hyper_op {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    (do {
    ((my  $last_pos) = $MATCH->to());
    if (!((do {
    (('>>' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))
}))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})
})));
            $MATCH
        };
        sub operator {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((((((((((((((((((((((((((((((do {
    (((((('.(' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((')' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, '.( )' );
    push( @{$List_a}, ${$MATCH->{'paren_parse'}} );
    $List_a
}))
}) || 1)))
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('.[' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $m2) = $grammar->square_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'square_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((']' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, '.[ ]' );
    push( @{$List_a}, ${$MATCH->{'square_parse'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('.' . chr(123) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $m2) = $grammar->curly_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'curly_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'block' );
    push( @{$List_a}, ${$MATCH->{'curly_parse'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('(' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((')' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, '( )' );
    push( @{$List_a}, ${$MATCH->{'paren_parse'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('[' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $m2) = $grammar->square_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'square_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((']' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, '[ ]' );
    push( @{$List_a}, ${$MATCH->{'square_parse'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    (('.<' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((('<' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
}) && (do {
    ((my  $m2) = Perlito::Grammar->ident($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'block' );
    push( @{$List_a}, do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, Val::Buf->new(('buf' => ${$MATCH->{'Perlito::Grammar.ident'}})) );
    $List_a
} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('->' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $last_pos) = $MATCH->to());
    if (!((do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (do {
    ((my  $m2) = $grammar->list_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ((my  $block) = (${$MATCH->{'list_parse'}})->{'end_block'});
    if ($block->sig()) {
        die(('Signature error in block'))
    };
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'block' );
    push( @{$List_a}, $block->stmts() );
    push( @{$List_a}, (${$MATCH->{'list_parse'}})->{'exp'} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((((((chr(123) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $last_pos) = $MATCH->to());
    if (!((do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (do {
    ((my  $m2) = Perlito::Grammar->exp_stmts($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $last_pos) = $MATCH->to());
    if (!((do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'block' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.exp_stmts'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('method' eq substr($str, $MATCH->to(), 6)) && ((($MATCH)->{to} = (6 + $MATCH->to()))))) && (do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2) = Perlito::Grammar->method_def($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.method_def'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.method_def'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('sub' eq substr($str, $MATCH->to(), 3)) && ((($MATCH)->{to} = (3 + $MATCH->to()))))) && (do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2) = Perlito::Grammar->sub_def($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.sub_def'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.sub_def'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('token' eq substr($str, $MATCH->to(), 5)) && ((($MATCH)->{to} = (5 + $MATCH->to()))))) && (do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2) = Perlito::Grammar->token($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.token'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.token'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('do' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2) = $grammar->statement_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'statement_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Do->new(('block' => ${$MATCH->{'statement_parse'}})) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((((chr(63) . chr(63) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $m2) = $grammar->ternary_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'ternary_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((chr(33) . chr(33) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'op' );
    push( @{$List_a}, chr(63) . chr(63) . ' ' . chr(33) . chr(33) );
    push( @{$List_a}, ${$MATCH->{'ternary_parse'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = Perlito::Grammar->var_ident($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.var_ident'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.var_ident'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((((chr(36) . '<' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $m2) = $grammar->capture_name($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'capture_name'} = $m2);
        1
    }
    else {
        0
    }
})) && ((('>' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Lookup->new(('obj' => Var->new(('sigil' => chr(36)), ('twigil' => ''), ('name' => chr(47)))), ('index_exp' => Val::Buf->new(('buf' => "".($MATCH->{'capture_name'}))))) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = Perlito::Precedence->op_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Precedence.op_parse'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Precedence.op_parse'}}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2) = Perlito::Grammar->ident($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1) = $MATCH->to());
    (do {
    ((do {
    ((my  $last_pos) = $MATCH->to());
    if (!((do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}) && (((chr(61) . '>' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))))
})
}));
    (($tmp)->{bool} = !!($MATCH));
    ($MATCH = $tmp);
    !!($MATCH)
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Val::Buf->new(('buf' => "".($MATCH->{'Perlito::Grammar.ident'}))) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((('True' eq substr($str, $MATCH->to(), 4)) && ((($MATCH)->{to} = (4 + $MATCH->to()))))) && (do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1) = $MATCH->to());
    (do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $m2) = Perlito::Grammar->word($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((('(' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
})
}));
    (($tmp)->{bool} = !($MATCH));
    ($MATCH = $tmp);
    !!($MATCH)
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Val::Bit->new(('bit' => 1)) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((('False' eq substr($str, $MATCH->to(), 5)) && ((($MATCH)->{to} = (5 + $MATCH->to()))))) && (do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1) = $MATCH->to());
    (do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $m2) = Perlito::Grammar->word($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((('(' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
})
}));
    (($tmp)->{bool} = !($MATCH));
    ($MATCH = $tmp);
    !!($MATCH)
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Val::Bit->new(('bit' => 0)) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((('and' eq substr($str, $MATCH->to(), 3)) && ((($MATCH)->{to} = (3 + $MATCH->to()))))) && (do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1) = $MATCH->to());
    (do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $m2) = Perlito::Grammar->word($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((('(' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
})
}));
    (($tmp)->{bool} = !($MATCH));
    ($MATCH = $tmp);
    !!($MATCH)
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'op' );
    push( @{$List_a}, 'and' );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((('not' eq substr($str, $MATCH->to(), 3)) && ((($MATCH)->{to} = (3 + $MATCH->to()))))) && (do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1) = $MATCH->to());
    (do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((my  $m2) = Perlito::Grammar->word($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((('(' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
})
}));
    (($tmp)->{bool} = !($MATCH));
    ($MATCH = $tmp);
    !!($MATCH)
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'op' );
    push( @{$List_a}, 'not' );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((((('use' eq substr($str, $MATCH->to(), 3)) && ((($MATCH)->{to} = (3 + $MATCH->to()))))) && (do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2) = Perlito::Grammar->full_ident($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $last_pos) = $MATCH->to());
    if (!((do {
    ((my  $pos1) = $MATCH->to());
    (do {
    (((('-' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $m2) = Perlito::Grammar->ident($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        if (exists($MATCH->{'Perlito::Grammar.ident'})) {
            push( @{($MATCH->{'Perlito::Grammar.ident'})}, $m2 )
        }
        else {
            ($MATCH->{'Perlito::Grammar.ident'} = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $m2 );
    $List_a
})
        };
        1
    }
    else {
        0
    }
}))
})
}))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (do {
    ((my  $m2) = $grammar->list_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Use->new(('mod' => ${$MATCH->{'Perlito::Grammar.full_ident'}})) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ((my  $pos1) = $MATCH->to());
    ((((do {
    (('package' eq substr($str, $MATCH->to(), 7)) && ((($MATCH)->{to} = (7 + $MATCH->to()))))
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((('class' eq substr($str, $MATCH->to(), 5)) && ((($MATCH)->{to} = (5 + $MATCH->to()))))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((('grammar' eq substr($str, $MATCH->to(), 7)) && ((($MATCH)->{to} = (7 + $MATCH->to()))))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((('role' eq substr($str, $MATCH->to(), 4)) && ((($MATCH)->{to} = (4 + $MATCH->to()))))))
}))
}) && (do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2) = Perlito::Grammar->grammar($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.grammar'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.grammar'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((((do {
    ((my  $m2) = Perlito::Grammar->declarator($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.declarator'} = $m2);
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2) = Perlito::Grammar->opt_type($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.opt_type'} = $m2);
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2) = Perlito::Grammar->opt_ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2) = Perlito::Grammar->var_ident($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.var_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Decl->new(('decl' => ${$MATCH->{'Perlito::Grammar.declarator'}}), ('type' => ${$MATCH->{'Perlito::Grammar.opt_type'}}), ('var' => ${$MATCH->{'Perlito::Grammar.var_ident'}})) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $m2) = $grammar->hyper_op($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'hyper_op'} = $m2);
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2) = Perlito::Grammar->ident($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((((((':' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $last_pos) = $MATCH->to());
    if (!((do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (do {
    ((my  $m2) = $grammar->list_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'methcall' );
    push( @{$List_a}, "".($MATCH->{'Perlito::Grammar.ident'}) );
    push( @{$List_a}, ${$MATCH->{'list_parse'}} );
    push( @{$List_a}, ${$MATCH->{'hyper_op'}} );
    $List_a
}))
}) || 1)))
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('(' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((')' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'methcall' );
    push( @{$List_a}, "".($MATCH->{'Perlito::Grammar.ident'}) );
    push( @{$List_a}, do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{'end_block'} = undef());
    ($Hash_a->{'exp'} = ${$MATCH->{'paren_parse'}});
    ($Hash_a->{'terminated'} = 0);
    $Hash_a
} );
    push( @{$List_a}, ${$MATCH->{'hyper_op'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'methcall_no_params' );
    push( @{$List_a}, "".($MATCH->{'Perlito::Grammar.ident'}) );
    push( @{$List_a}, ${$MATCH->{'hyper_op'}} );
    $List_a
}))
}) || 1)))
}))
})))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2) = Perlito::Grammar->optional_namespace_before_ident($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $m2) = Perlito::Grammar->ident($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    (((do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $m2) = $grammar->list_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'funcall' );
    push( @{$List_a}, "".($MATCH->{'Perlito::Grammar.optional_namespace_before_ident'}) );
    push( @{$List_a}, "".($MATCH->{'Perlito::Grammar.ident'}) );
    push( @{$List_a}, ${$MATCH->{'list_parse'}} );
    $List_a
}))
}) || 1)))
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1) = $MATCH->to());
    (do {
    (('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})
}));
    (($tmp)->{bool} = !!($MATCH));
    ($MATCH = $tmp);
    !!($MATCH)
}) && (((do {
    ((my  $namespace) = "".($MATCH->{'Perlito::Grammar.optional_namespace_before_ident'}));
    ((my  $name) = "".($MATCH->{'Perlito::Grammar.ident'}));
    if ($namespace) {
        ($name = ($namespace . '::' . $name))
    };
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Proto->new(('name' => $name)) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'funcall_no_params' );
    push( @{$List_a}, "".($MATCH->{'Perlito::Grammar.optional_namespace_before_ident'}) );
    push( @{$List_a}, "".($MATCH->{'Perlito::Grammar.ident'}) );
    $List_a
}))
}) || 1)))
}))
})))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = Perlito::Grammar->val_num($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.val_num'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.val_num'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = Perlito::Grammar->val_int($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.val_int'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.val_int'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = Perlito::Grammar->val_buf($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.val_buf'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.val_buf'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'space' );
    push( @{$List_a}, ' ' );
    $List_a
}))
}) || 1))))
}))
})));
            $MATCH
        };
        sub has_newline_after {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    (((do {
    ((chr(35) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((do {
    ((my  $m2) = Perlito::Grammar->is_newline($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = Perlito::Grammar->space($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $m2) = $grammar->has_newline_after($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))
}))
})));
            $MATCH
        };
        sub has_no_comma_or_colon_after {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    (do {
    (((do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $tmp) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1) = $MATCH->to());
    (do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((',' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((((':' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
})
}));
    (($tmp)->{bool} = !($MATCH));
    ($MATCH = $tmp);
    !!($MATCH)
})) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})
})));
            $MATCH
        };
        sub list_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $expr);
            ((my  $last_pos) = $pos);
            ((my  $is_first_token) = 1);
            ((my  $lexer_stack) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            ((my  $terminated) = 0);
            ((my  $last_token_was_space) = 1);
            ((my  $get_token) = sub  {
    (my  $v);
    if (scalar( @{$lexer_stack} )) {
        ($v = pop( @{$lexer_stack} ));
        if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito::Precedence::is_fixity_type('prefix', $v->[1]))))) {
            ($v->[0] = 'end')
        }
    }
    else {
        ((my  $m) = $self->operator($str, $last_pos));
        if (!($m)) {
            return scalar (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'end' );
    push( @{$List_a}, '*end*' );
    $List_a
})
        };
        ($v = ${$m});
        if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito::Precedence::is_fixity_type('prefix', $v->[1]))))) {
            ($v->[0] = 'end')
        };
        if (($v->[0] ne 'end')) {
            ($last_pos = $m->to())
        }
    };
    if (((((($v->[0]) eq 'postfix_or_term')) && ((($v->[1]) eq 'block'))) && $last_token_was_space)) {
        if ($self->has_newline_after($str, $last_pos)) {
            ($terminated = 1);
            push( @{$lexer_stack}, do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'end' );
    push( @{$List_a}, '*end*' );
    $List_a
} )
        }
        else {
            if ($self->has_no_comma_or_colon_after($str, $last_pos)) {
                ($terminated = 1);
                push( @{$lexer_stack}, do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'end' );
    push( @{$List_a}, '*end*' );
    $List_a
} )
            }
        }
    };
    ($last_token_was_space = (($v->[0] eq 'space')));
    ($is_first_token = 0);
    return scalar ($v)
});
            ((my  $prec) = Perlito::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'and' );
    push( @{$List_a}, 'or' );
    push( @{$List_a}, chr(33) . chr(33) );
    push( @{$List_a}, ']' );
    push( @{$List_a}, ')' );
    push( @{$List_a}, chr(125) );
    push( @{$List_a}, chr(59) );
    push( @{$List_a}, 'if' );
    push( @{$List_a}, 'else' );
    push( @{$List_a}, 'elsif' );
    push( @{$List_a}, 'unless' );
    push( @{$List_a}, 'when' );
    push( @{$List_a}, 'for' );
    push( @{$List_a}, 'while' );
    push( @{$List_a}, 'loop' );
    $List_a
})));
            ((my  $res) = $prec->precedence_parse());
            if ((scalar( @{$res} ) == 0)) {
                return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{'exp'} = '*undef*');
    ($Hash_a->{'end_block'} = undef());
    ($Hash_a->{'terminated'} = undef());
    $Hash_a
})))
            };
            (my  $block);
            if ((scalar( @{$res} ) > 1)) {
                ($block = pop( @{$res} ));
                ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
            };
            ((my  $result) = pop_term($res));
            if ((scalar( @{$res} ) > 0)) {
                ($block = pop( @{$res} ));
                ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
            };
            return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{'exp'} = $result);
    ($Hash_a->{'end_block'} = $block);
    ($Hash_a->{'terminated'} = $terminated);
    $Hash_a
})))
        };
        sub circumfix_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            my $delimiter = $_[3];
            (my  $expr);
            ((my  $last_pos) = $pos);
            ((my  $get_token) = sub  {
    ((my  $m) = $self->operator($str, $last_pos));
    if (!($m)) {
        die(('Expected closing delimiter: '), (($delimiter)), ' near ', $last_pos)
    };
    ((my  $v) = ${$m});
    if (($v->[0] ne 'end')) {
        ($last_pos = $m->to())
    };
    return scalar ($v)
});
            ((my  $prec) = Perlito::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => $delimiter)));
            ((my  $res) = $prec->precedence_parse());
            ($res = pop_term($res));
            if (!((defined($res)))) {
                ($res = '*undef*')
            };
            return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => $res)))
        };
        sub ternary_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            return scalar ($self->circumfix_parse($str, $pos, do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, chr(33) . chr(33) );
    $List_a
}))
        };
        sub curly_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            return scalar ($self->circumfix_parse($str, $pos, do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, chr(125) );
    $List_a
}))
        };
        sub square_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            return scalar ($self->circumfix_parse($str, $pos, do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, ']' );
    $List_a
}))
        };
        sub paren_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            return scalar ($self->circumfix_parse($str, $pos, do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, ')' );
    $List_a
}))
        };
        sub exp_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $expr);
            ((my  $last_pos) = $pos);
            ((my  $lexer_stack) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            ((my  $terminated) = 0);
            ((my  $get_token) = sub  {
    (my  $v);
    if (scalar( @{$lexer_stack} )) {
        ($v = pop( @{$lexer_stack} ))
    }
    else {
        ((my  $m) = $self->operator($str, $last_pos));
        if (!($m)) {
            return scalar (do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'end' );
    push( @{$List_a}, '*end*' );
    $List_a
})
        };
        ($v = ${$m});
        if (($v->[0] ne 'end')) {
            ($last_pos = $m->to())
        }
    };
    if (((((((((($v->[0]) eq 'postfix_or_term')) && ((($v->[1]) eq 'block')))) || ((((($v->[0]) eq 'term')) && (Main::isa(($v->[1]), 'Sub'))))) || ((((($v->[0]) eq 'term')) && (Main::isa(($v->[1]), 'Method'))))) || ((((($v->[0]) eq 'term')) && (Main::isa(($v->[1]), 'Do'))))) || ((((($v->[0]) eq 'term')) && (Main::isa(($v->[1]), 'CompUnit')))))) {
        if ($self->has_newline_after($str, $last_pos)) {
            ($terminated = 1);
            push( @{$lexer_stack}, do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'end' );
    push( @{$List_a}, '*end*' );
    $List_a
} )
        }
    };
    return scalar ($v)
});
            ((my  $prec) = Perlito::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, ']' );
    push( @{$List_a}, ')' );
    push( @{$List_a}, chr(125) );
    push( @{$List_a}, chr(59) );
    push( @{$List_a}, 'if' );
    push( @{$List_a}, 'else' );
    push( @{$List_a}, 'elsif' );
    push( @{$List_a}, 'unless' );
    push( @{$List_a}, 'when' );
    push( @{$List_a}, 'for' );
    push( @{$List_a}, 'while' );
    push( @{$List_a}, 'loop' );
    $List_a
})));
            ((my  $res) = $prec->precedence_parse());
            if ((scalar( @{$res} ) == 0)) {
                return scalar (Perlito::Match->new(('bool' => 0)))
            };
            (my  $block);
            if ((scalar( @{$res} ) > 1)) {
                ($block = pop( @{$res} ));
                ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
            };
            ((my  $result) = pop_term($res));
            if ((scalar( @{$res} ) > 0)) {
                ($block = pop( @{$res} ));
                if (!((Main::isa($block, 'Lit::Block')))) {
                    ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
                }
            };
            return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{'exp'} = $result);
    ($Hash_a->{'end_block'} = $block);
    ($Hash_a->{'terminated'} = $terminated);
    $Hash_a
})))
        };
        sub exp_stmt {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((((((do {
    ((do {
    ((my  $m2) = Perlito::Grammar->if($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.if'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Grammar.if'}}))
}) || 1)))
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = Perlito::Grammar->unless($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.unless'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Grammar.unless'}}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = Perlito::Grammar->when($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.when'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Grammar.when'}}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = Perlito::Grammar->for($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.for'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Grammar.for'}}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = Perlito::Grammar->while($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.while'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Grammar.while'}}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2) = Perlito::Grammar->loop($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.loop'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Grammar.loop'}}))
}) || 1))))
}))
})));
            $MATCH
        };
        sub statement_modifier {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    ((((((do {
    (('if' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((('unless' eq substr($str, $MATCH->to(), 6)) && ((($MATCH)->{to} = (6 + $MATCH->to()))))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((('when' eq substr($str, $MATCH->to(), 4)) && ((($MATCH)->{to} = (4 + $MATCH->to()))))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((('for' eq substr($str, $MATCH->to(), 3)) && ((($MATCH)->{to} = (3 + $MATCH->to()))))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((('while' eq substr($str, $MATCH->to(), 5)) && ((($MATCH)->{to} = (5 + $MATCH->to()))))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((('loop' eq substr($str, $MATCH->to(), 4)) && ((($MATCH)->{to} = (4 + $MATCH->to()))))))
}))
})));
            $MATCH
        };
        sub delimited_statement {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    (do {
    ((do {
    ((my  $last_pos) = $MATCH->to());
    if (!((do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}) && (do {
    ((my  $pos1) = $MATCH->to());
    ((do {
    ((((chr(59) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $last_pos) = $MATCH->to());
    if (!((do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ((my  $m2) = $grammar->statement_parse($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'statement_parse'} = $m2);
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $last_pos) = $MATCH->to());
    if (!((do {
    ((chr(59) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (do {
    ((my  $last_pos) = $MATCH->to());
    if (!((do {
    ((my  $m2) = Perlito::Grammar->ws($str, $MATCH->to()));
    if ($m2) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'statement_parse'}}))
}) || 1))))
}))
}))
})
})));
            $MATCH
        };
        sub statement_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $expr);
            ((my  $last_pos) = $pos);
            ((my  $lexer_stack) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            (my  $res);
            ($res = $self->exp_stmt($str, $pos));
            if ($res) {
                return scalar ($res)
            };
            ($res = $self->exp_parse($str, $pos));
            if (!(($res))) {
                return scalar ($res)
            };
            if (Main::isa((${$res})->{'exp'}, 'Lit::Block')) {
                ((${$res})->{'exp'} = Do->new(('block' => (${$res})->{'exp'})))
            };
            if ((${$res})->{'end_block'}) {
                die(('Unexpected block after expression near '), $pos)
            };
            if ((${$res})->{'terminated'}) {
                (($res)->{capture} = (${$res})->{'exp'});
                return scalar ($res)
            };
            ((my  $modifier) = $self->statement_modifier($str, $res->to()));
            if (!(($modifier))) {
                (($res)->{capture} = (${$res})->{'exp'});
                return scalar ($res)
            };
            ((my  $modifier_exp) = $self->exp_parse($str, $modifier->to()));
            if (!(($modifier_exp))) {
                die(('Expected expression after ' . chr(39)), $modifier, (chr(39)))
            };
            if ((${$modifier_exp})->{'end_block'}) {
                die(('Unexpected block after expression near '), $modifier->to())
            };
            ($modifier = "".($modifier));
            if (($modifier eq 'if')) {
                return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => If->new(('cond' => (${$modifier_exp})->{'exp'}), ('body' => Lit::Block->new(('stmts' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, (${$res})->{'exp'} );
    $List_a
}))), ('otherwise' => Lit::Block->new(('stmts' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
})))))))
            };
            if (($modifier eq 'unless')) {
                return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => If->new(('cond' => (${$modifier_exp})->{'exp'}), ('body' => Lit::Block->new(('stmts' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
}))), ('otherwise' => Lit::Block->new(('stmts' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, (${$res})->{'exp'} );
    $List_a
})))))))
            };
            if (($modifier eq 'while')) {
                return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => While->new(('cond' => (${$modifier_exp})->{'exp'}), ('body' => Lit::Block->new(('stmts' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, (${$res})->{'exp'} );
    $List_a
})))))))
            };
            if (($modifier eq 'for')) {
                return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => For->new(('cond' => (${$modifier_exp})->{'exp'}), ('body' => Lit::Block->new(('stmts' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, (${$res})->{'exp'} );
    $List_a
})))))))
            };
            die(('Unexpected statement modifier ' . chr(39) . $modifier . chr(39)))
        }
    }


}

1;
