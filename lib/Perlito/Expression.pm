# Do not edit this file - Generated by Perlito 7.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito::Perl5::Runtime;
use Perlito::Perl5::Prelude;
our $MATCH = Perlito::Match->new();
{
package GLOBAL;
    sub new { shift; bless { @_ }, "GLOBAL" }
    {
    package Perlito::Expression;
        sub new { shift; bless { @_ }, "Perlito::Expression" }
        use Perlito::Precedence;
        use Perlito::Grammar;
        use Perlito::Perl5::Emitter;
        sub expand_list {
            my $param_list = $_[0];
            if (Main::bool(((Main::isa($param_list, 'Apply')) && ((($param_list->code()) eq 'list:' . chr(60) . ',' . chr(62)))))) {
                ((my  $args = undef) = do {
    (my  $List_a = []);
    (my  $List_v = []);
    $List_a
});
                for my $v ( @{(($param_list->arguments()) || []) || []} ) {
                    if (Main::bool(defined($v))) {
                        push( @{$args}, $v )
                    }
                };
                return scalar ($args)
            }
            else {
                if (Main::bool(($param_list eq '*undef*'))) {
                    return scalar (do {
    (my  $List_a = []);
    (my  $List_v = []);
    $List_a
})
                }
                else {
                    return scalar (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, $param_list );
    $List_a
})
                }
            }
        };
        sub block_or_hash {
            my $o = $_[0];
            if (Main::bool(defined($o->sig()))) {
                return scalar ($o)
            };
            ((my  $stmts = undef) = $o->stmts());
            if (Main::bool(((!Main::bool((defined($stmts)))) || (((scalar( @{$stmts} )) == 0))))) {
                return scalar (Lit::Hash->new(('hash1' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    $List_a
})))
            };
            if (Main::bool(((scalar( @{$stmts} )) != 1))) {
                return scalar ($o)
            };
            ((my  $stmt = undef) = $stmts->[0]);
            if (Main::bool(!Main::bool((Main::isa($stmt, 'Apply'))))) {
                return scalar ($o)
            };
            if (Main::bool((($stmt->code()) eq 'infix:' . chr(60) . chr(61) . chr(62) . chr(62)))) {
                return scalar (Lit::Hash->new(('hash1' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, $stmt );
    $List_a
})))
            };
            if (Main::bool((($stmt->code()) ne 'list:' . chr(60) . ',' . chr(62)))) {
                return scalar ($o)
            };
            for my $item ( @{(($stmt->arguments()) || []) || []} ) {
                if (Main::bool((Main::isa($item, 'Apply') && (($item->code()) eq 'infix:' . chr(60) . chr(61) . chr(62) . chr(62))))) {
                    return scalar (Lit::Hash->new(('hash1' => expand_list($stmt))))
                }
            };
            return scalar ($o)
        };
        sub pop_term {
            my $num_stack = $_[0];
            ((my  $v = undef) = pop( @{$num_stack} ));
            if (Main::bool(Main::isa($v, 'Array'))) {
                if (Main::bool(($v->[1] eq 'methcall_no_params'))) {
                    ($v = Call->new(('invocant' => undef), ('method' => $v->[2]), ('hyper' => $v->[3])));
                    return scalar ($v)
                };
                if (Main::bool(($v->[1] eq 'funcall_no_params'))) {
                    ($v = Apply->new(('code' => $v->[3]), ('namespace' => $v->[2])));
                    return scalar ($v)
                };
                if (Main::bool(($v->[1] eq 'methcall'))) {
                    if (Main::bool(($v->[3])->{'end_block'})) {
                        unshift( @{$num_stack}, ($v->[3])->{'end_block'} )
                    };
                    ((my  $param_list = undef) = expand_list(($v->[3])->{'exp'}));
                    ($v = Call->new(('invocant' => undef), ('method' => $v->[2]), ('arguments' => $param_list), ('hyper' => $v->[4])));
                    return scalar ($v)
                };
                if (Main::bool(($v->[1] eq 'funcall'))) {
                    if (Main::bool(($v->[4])->{'end_block'})) {
                        unshift( @{$num_stack}, ($v->[4])->{'end_block'} )
                    };
                    ((my  $param_list = undef) = expand_list(($v->[4])->{'exp'}));
                    ($v = Apply->new(('code' => $v->[3]), ('arguments' => $param_list), ('namespace' => $v->[2])));
                    return scalar ($v)
                };
                if (Main::bool(($v->[1] eq chr(40) . ' ' . chr(41)))) {
                    ((my  $param_list = undef) = expand_list($v->[2]));
                    ($v = Apply->new(('code' => 'circumfix:' . chr(60) . chr(40) . ' ' . chr(41) . chr(62)), ('arguments' => $param_list), ('namespace' => '')));
                    return scalar ($v)
                };
                if (Main::bool(($v->[1] eq chr(91) . ' ' . chr(93)))) {
                    ((my  $param_list = undef) = expand_list($v->[2]));
                    ($v = Lit::Array->new(('array1' => $param_list)));
                    return scalar ($v)
                };
                if (Main::bool(($v->[1] eq 'block'))) {
                    ($v = Lit::Block->new(('stmts' => $v->[2]), ('sig' => $v->[3])));
                    ($v = block_or_hash($v));
                    return scalar ($v)
                };
                if (Main::bool(($v->[1] eq '.' . chr(40) . ' ' . chr(41)))) {
                    ($v = Call->new(('invocant' => undef), ('method' => 'postcircumfix:' . chr(60) . chr(40) . ' ' . chr(41) . chr(62)), ('arguments' => $v->[2]), ('hyper' => 0)));
                    return scalar ($v)
                };
                if (Main::bool(($v->[1] eq '.' . chr(91) . ' ' . chr(93)))) {
                    ($v = Index->new(('obj' => undef), ('index_exp' => $v->[2])));
                    return scalar ($v)
                };
                if (Main::bool(($v->[1] eq '.' . chr(123) . ' ' . chr(125)))) {
                    ($v = Lookup->new(('obj' => undef), ('index_exp' => $v->[2])));
                    return scalar ($v)
                };
                if (Main::bool((Main::isa(($v->[1]), 'Array') && (((scalar( @{($v->[1])} )) == 2))))) {
                    ($v = Apply->new(('code' => 'pair'), ('arguments' => $v->[1]), ('namespace' => '')));
                    return scalar ($v)
                };
                return scalar ($v->[1])
            };
            return scalar ($v)
        };
        sub reduce_postfix {
            my $op = $_[0];
            my $value = $_[1];
            ((my  $v = undef) = $op);
            if (Main::bool(($v->[1] eq 'methcall_no_params'))) {
                ($v = Call->new(('invocant' => $value), ('method' => $v->[2]), ('hyper' => $v->[3])));
                return scalar ($v)
            };
            if (Main::bool(($v->[1] eq 'funcall_no_params'))) {
                die('unexpected function call');
                push( @{$v}, $value );
                return scalar ($v)
            };
            if (Main::bool(($v->[1] eq 'methcall'))) {
                ((my  $param_list = undef) = expand_list(($v->[3])->{'exp'}));
                ($v = Call->new(('invocant' => $value), ('method' => $v->[2]), ('arguments' => $param_list), ('hyper' => $v->[4])));
                return scalar ($v)
            };
            if (Main::bool(($v->[1] eq 'funcall'))) {
                die('unexpected function call');
                push( @{$v}, $value );
                return scalar ($v)
            };
            if (Main::bool(($v->[1] eq chr(40) . ' ' . chr(41)))) {
                ((my  $param_list = undef) = expand_list($v->[2]));
                if (Main::bool((Main::isa($value, 'Apply') && !Main::bool((defined($value->arguments())))))) {
                    (($value)->{arguments} = $param_list);
                    return scalar ($value)
                };
                if (Main::bool((Main::isa($value, 'Call') && !Main::bool((defined($value->arguments())))))) {
                    (($value)->{arguments} = $param_list);
                    return scalar ($value)
                };
                ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:' . chr(60) . chr(40) . ' ' . chr(41) . chr(62)), ('arguments' => $param_list), ('hyper' => 0)));
                return scalar ($v)
            };
            if (Main::bool(($v->[1] eq chr(91) . ' ' . chr(93)))) {
                ($v = Index->new(('obj' => $value), ('index_exp' => $v->[2])));
                return scalar ($v)
            };
            if (Main::bool(($v->[1] eq 'block'))) {
                ($v = Lookup->new(('obj' => $value), ('index_exp' => ($v->[2])->[0])));
                return scalar ($v)
            };
            if (Main::bool(($v->[1] eq '.' . chr(40) . ' ' . chr(41)))) {
                ((my  $param_list = undef) = expand_list($v->[2]));
                ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:' . chr(60) . chr(40) . ' ' . chr(41) . chr(62)), ('arguments' => $param_list), ('hyper' => 0)));
                return scalar ($v)
            };
            if (Main::bool(($v->[1] eq '.' . chr(91) . ' ' . chr(93)))) {
                ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:' . chr(60) . chr(91) . ' ' . chr(93) . chr(62)), ('arguments' => $v->[2]), ('hyper' => 0)));
                return scalar ($v)
            };
            if (Main::bool(($v->[1] eq '.' . chr(123) . ' ' . chr(125)))) {
                ($v = Call->new(('invocant' => $value), ('method' => 'postcircumfix:' . chr(60) . chr(123) . ' ' . chr(125) . chr(62)), ('arguments' => $v->[2]), ('hyper' => 0)));
                return scalar ($v)
            };
            push( @{$op}, $value );
            return scalar ($op)
        };
        ((my  $reduce_to_ast = undef) = sub  {
    my $op_stack = $_[0];
    my $num_stack = $_[1];
    ((my  $last_op = undef) = shift( @{$op_stack} ));
    if (Main::bool(($last_op->[0] eq 'prefix'))) {
        push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'prefix:' . chr(60) . $last_op->[1] . chr(62)), ('arguments' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, pop_term($num_stack) );
    $List_a
})) )
    }
    else {
        if (Main::bool(($last_op->[0] eq 'postfix'))) {
            push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'postfix:' . chr(60) . $last_op->[1] . chr(62)), ('arguments' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, pop_term($num_stack) );
    $List_a
})) )
        }
        else {
            if (Main::bool(($last_op->[0] eq 'postfix_or_term'))) {
                push( @{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)) )
            }
            else {
                if (Main::bool(Perlito::Precedence::is_assoc_type('list', $last_op->[1]))) {
                    (my  $arg = undef);
                    if (Main::bool((scalar( @{$num_stack} ) < 2))) {
                        ((my  $v2 = undef) = pop_term($num_stack));
                        if (Main::bool(((Main::isa($v2, 'Apply')) && (($v2->code() eq ('list:' . chr(60) . $last_op->[1] . chr(62))))))) {
                            push( @{($v2->arguments())}, undef );
                            push( @{$num_stack}, $v2 )
                        }
                        else {
                            push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'list:' . chr(60) . $last_op->[1] . chr(62)), ('arguments' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, $v2 );
    push( @{$List_a}, undef );
    $List_a
})) )
                        };
                        return ()
                    }
                    else {
                        ((my  $v2 = undef) = pop_term($num_stack));
                        ($arg = do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, pop_term($num_stack) );
    push( @{$List_a}, $v2 );
    $List_a
})
                    };
                    if (Main::bool((((Main::isa(($arg->[0]), 'Apply')) && (($last_op->[0] eq 'infix'))) && ((($arg->[0])->code() eq ('list:' . chr(60) . $last_op->[1] . chr(62))))))) {
                        push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => ($arg->[0])->code()), ('arguments' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    ($List_v = ((($arg->[0])->arguments()) || []));
    for my $x ( @{[0 .. ((scalar( @{$List_v} ) - 1))] || []} ) {
        push( @{$List_a}, $List_v->[$x] )
    };
    push( @{$List_a}, $arg->[1] );
    $List_a
})) );
                        return ()
                    };
                    push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'list:' . chr(60) . $last_op->[1] . chr(62)), ('arguments' => $arg)) )
                }
                else {
                    if (Main::bool(Perlito::Precedence::is_assoc_type('chain', $last_op->[1]))) {
                        if (Main::bool((scalar( @{$num_stack} ) < 2))) {
                            die('Missing value after operator ' . $last_op->[1])
                        };
                        ((my  $v2 = undef) = pop_term($num_stack));
                        ((my  $arg = undef) = do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, pop_term($num_stack) );
    push( @{$List_a}, $v2 );
    $List_a
});
                        push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'infix:' . chr(60) . $last_op->[1] . chr(62)), ('arguments' => $arg)) )
                    }
                    else {
                        if (Main::bool(($last_op->[0] eq 'ternary'))) {
                            if (Main::bool(((scalar( @{$num_stack} ) < 2)))) {
                                die('Missing value after ternary operator')
                            };
                            ((my  $v2 = undef) = pop_term($num_stack));
                            push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'ternary:' . chr(60) . $last_op->[1] . chr(62)), ('arguments' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, pop_term($num_stack) );
    push( @{$List_a}, $last_op->[2] );
    push( @{$List_a}, $v2 );
    $List_a
})) )
                        }
                        else {
                            if (Main::bool(((scalar( @{$num_stack} ) < 2)))) {
                                die('missing value after operator ' . chr(39) . $last_op->[1] . chr(39))
                            };
                            ((my  $v2 = undef) = pop_term($num_stack));
                            push( @{$num_stack}, Apply->new(('namespace' => ''), ('code' => 'infix:' . chr(60) . $last_op->[1] . chr(62)), ('arguments' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, pop_term($num_stack) );
    push( @{$List_a}, $v2 );
    $List_a
})) )
                        }
                    }
                }
            }
        }
    }
});
        sub capture_name {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    ((do {
    ((my  $m2 = undef) = Perlito::Grammar->full_ident($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $last_pos = undef) = $MATCH->to());
    if (Main::bool(!Main::bool((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    (((('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->ident($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        if (Main::bool(exists($MATCH->{'Perlito::Grammar.ident'}))) {
            push( @{($MATCH->{'Perlito::Grammar.ident'})}, $m2 )
        }
        else {
            ($MATCH->{'Perlito::Grammar.ident'} = do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, $m2 );
    $List_a
})
        };
        1
    }
    else {
        0
    }
}))
})
})))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))
})
})));
            $MATCH
        };
        sub hyper_op {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    ((my  $last_pos = undef) = $MATCH->to());
    if (Main::bool(!Main::bool((do {
    ((chr(62) . chr(62) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))
})))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})
})));
            $MATCH
        };
        sub operator {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    ((((((((((((((((((((((((((((((do {
    (((((('.' . chr(40) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = $grammar->paren_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((chr(41) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, '.' . chr(40) . ' ' . chr(41) );
    push( @{$List_a}, ${$MATCH->{'paren_parse'}} );
    $List_a
}))
}) || 1)))
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('.' . chr(91) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = $grammar->square_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'square_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((chr(93) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, '.' . chr(91) . ' ' . chr(93) );
    push( @{$List_a}, ${$MATCH->{'square_parse'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('.' . chr(123) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = $grammar->curly_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'curly_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'block' );
    push( @{$List_a}, ${$MATCH->{'curly_parse'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((((chr(40) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = $grammar->paren_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((chr(41) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, chr(40) . ' ' . chr(41) );
    push( @{$List_a}, ${$MATCH->{'paren_parse'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((((chr(91) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = $grammar->square_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'square_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((chr(93) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, chr(91) . ' ' . chr(93) );
    push( @{$List_a}, ${$MATCH->{'square_parse'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ((my  $pos1 = undef) = $MATCH->to());
    ((do {
    (('.' . chr(60) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((((chr(60) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
}) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->ident($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
})) && (((chr(62) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'block' );
    push( @{$List_a}, do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, Val::Buf->new(('buf' => ${$MATCH->{'Perlito::Grammar.ident'}})) );
    $List_a
} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('-' . chr(62) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $last_pos = undef) = $MATCH->to());
    if (Main::bool(!Main::bool((do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (do {
    ((my  $m2 = undef) = $grammar->list_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ((my  $block = undef) = (${$MATCH->{'list_parse'}})->{'end_block'});
    if (Main::bool($block->sig())) {
        die('Signature error in block')
    };
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'block' );
    push( @{$List_a}, $block->stmts() );
    push( @{$List_a}, (${$MATCH->{'list_parse'}})->{'exp'} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((((((chr(123) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $last_pos = undef) = $MATCH->to());
    if (Main::bool(!Main::bool((do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->exp_stmts($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $last_pos = undef) = $MATCH->to());
    if (Main::bool(!Main::bool((do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (((chr(125) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'block' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.exp_stmts'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('method' eq substr($str, $MATCH->to(), 6)) && ((($MATCH)->{to} = (6 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->method_def($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.method_def'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.method_def'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('sub' eq substr($str, $MATCH->to(), 3)) && ((($MATCH)->{to} = (3 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->sub_def($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.sub_def'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.sub_def'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('token' eq substr($str, $MATCH->to(), 5)) && ((($MATCH)->{to} = (5 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->token($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.token'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.token'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('do' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2 = undef) = $grammar->statement_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'statement_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Do->new(('block' => ${$MATCH->{'statement_parse'}})) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((((chr(63) . chr(63) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = $grammar->ternary_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'ternary_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((chr(33) . chr(33) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'op' );
    push( @{$List_a}, chr(63) . chr(63) . ' ' . chr(33) . chr(33) );
    push( @{$List_a}, ${$MATCH->{'ternary_parse'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->var_ident($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.var_ident'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.var_ident'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((((chr(36) . chr(60) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = $grammar->capture_name($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'capture_name'} = $m2);
        1
    }
    else {
        0
    }
})) && (((chr(62) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Lookup->new(('obj' => Var->new(('sigil' => chr(36)), ('twigil' => ''), ('name' => chr(47)))), ('index_exp' => Val::Buf->new(('buf' => ("" . $MATCH->{'capture_name'}))))) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2 = undef) = Perlito::Precedence->op_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Precedence.op_parse'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Precedence.op_parse'}}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2 = undef) = Perlito::Grammar->ident($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $tmp = undef) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    ((do {
    ((my  $last_pos = undef) = $MATCH->to());
    if (Main::bool(!Main::bool((do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}) && (((chr(61) . chr(62) eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))))
})
}));
    (($tmp)->{bool} = Main::bool($MATCH));
    ($MATCH = $tmp);
    Main::bool($MATCH)
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Val::Buf->new(('buf' => ("" . $MATCH->{'Perlito::Grammar.ident'}))) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((('True' eq substr($str, $MATCH->to(), 4)) && ((($MATCH)->{to} = (4 + $MATCH->to()))))) && (do {
    ((my  $tmp = undef) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    ((my  $pos1 = undef) = $MATCH->to());
    ((do {
    ((my  $m2 = undef) = Perlito::Grammar->word($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((((chr(40) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
})
}));
    (($tmp)->{bool} = !Main::bool($MATCH));
    ($MATCH = $tmp);
    Main::bool($MATCH)
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Val::Bit->new(('bit' => 1)) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((('False' eq substr($str, $MATCH->to(), 5)) && ((($MATCH)->{to} = (5 + $MATCH->to()))))) && (do {
    ((my  $tmp = undef) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    ((my  $pos1 = undef) = $MATCH->to());
    ((do {
    ((my  $m2 = undef) = Perlito::Grammar->word($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((((chr(40) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
})
}));
    (($tmp)->{bool} = !Main::bool($MATCH));
    ($MATCH = $tmp);
    Main::bool($MATCH)
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Val::Bit->new(('bit' => 0)) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((('and' eq substr($str, $MATCH->to(), 3)) && ((($MATCH)->{to} = (3 + $MATCH->to()))))) && (do {
    ((my  $tmp = undef) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    ((my  $pos1 = undef) = $MATCH->to());
    ((do {
    ((my  $m2 = undef) = Perlito::Grammar->word($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((((chr(40) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
})
}));
    (($tmp)->{bool} = !Main::bool($MATCH));
    ($MATCH = $tmp);
    Main::bool($MATCH)
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'op' );
    push( @{$List_a}, 'and' );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((('not' eq substr($str, $MATCH->to(), 3)) && ((($MATCH)->{to} = (3 + $MATCH->to()))))) && (do {
    ((my  $tmp = undef) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    ((my  $pos1 = undef) = $MATCH->to());
    ((do {
    ((my  $m2 = undef) = Perlito::Grammar->word($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((((chr(40) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
})
}));
    (($tmp)->{bool} = !Main::bool($MATCH));
    ($MATCH = $tmp);
    Main::bool($MATCH)
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'op' );
    push( @{$List_a}, 'not' );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((((('use' eq substr($str, $MATCH->to(), 3)) && ((($MATCH)->{to} = (3 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->full_ident($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $last_pos = undef) = $MATCH->to());
    if (Main::bool(!Main::bool((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    (((('-' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->ident($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        if (Main::bool(exists($MATCH->{'Perlito::Grammar.ident'}))) {
            push( @{($MATCH->{'Perlito::Grammar.ident'})}, $m2 )
        }
        else {
            ($MATCH->{'Perlito::Grammar.ident'} = do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, $m2 );
    $List_a
})
        };
        1
    }
    else {
        0
    }
}))
})
})))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (do {
    ((my  $m2 = undef) = $grammar->list_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Use->new(('mod' => ${$MATCH->{'Perlito::Grammar.full_ident'}})) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ((my  $pos1 = undef) = $MATCH->to());
    ((((do {
    (('package' eq substr($str, $MATCH->to(), 7)) && ((($MATCH)->{to} = (7 + $MATCH->to()))))
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((('class' eq substr($str, $MATCH->to(), 5)) && ((($MATCH)->{to} = (5 + $MATCH->to()))))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((('grammar' eq substr($str, $MATCH->to(), 7)) && ((($MATCH)->{to} = (7 + $MATCH->to()))))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((('role' eq substr($str, $MATCH->to(), 4)) && ((($MATCH)->{to} = (4 + $MATCH->to()))))))
}))
}) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->grammar($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.grammar'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.grammar'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((((((do {
    ((my  $m2 = undef) = Perlito::Grammar->declarator($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.declarator'} = $m2);
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->opt_type($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.opt_type'} = $m2);
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->opt_ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->var_ident($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.var_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Decl->new(('decl' => ${$MATCH->{'Perlito::Grammar.declarator'}}), ('type' => ${$MATCH->{'Perlito::Grammar.opt_type'}}), ('var' => ${$MATCH->{'Perlito::Grammar.var_ident'}})) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((((('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $m2 = undef) = $grammar->hyper_op($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'hyper_op'} = $m2);
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->ident($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $pos1 = undef) = $MATCH->to());
    ((do {
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $m2 = undef) = $grammar->list_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'methcall' );
    push( @{$List_a}, ("" . $MATCH->{'Perlito::Grammar.ident'}) );
    push( @{$List_a}, ${$MATCH->{'list_parse'}} );
    push( @{$List_a}, ${$MATCH->{'hyper_op'}} );
    $List_a
}))
}) || 1)))
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'methcall_no_params' );
    push( @{$List_a}, ("" . $MATCH->{'Perlito::Grammar.ident'}) );
    push( @{$List_a}, ${$MATCH->{'hyper_op'}} );
    $List_a
}))
}) || 1)))
}))
})))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ((my  $m2 = undef) = Perlito::Grammar->optional_namespace_before_ident($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $m2 = undef) = Perlito::Grammar->ident($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
})) && (do {
    ((my  $pos1 = undef) = $MATCH->to());
    (((do {
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $m2 = undef) = $grammar->list_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'funcall' );
    push( @{$List_a}, ("" . $MATCH->{'Perlito::Grammar.optional_namespace_before_ident'}) );
    push( @{$List_a}, ("" . $MATCH->{'Perlito::Grammar.ident'}) );
    push( @{$List_a}, ${$MATCH->{'list_parse'}} );
    $List_a
}))
}) || 1)))
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $tmp = undef) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    (('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})
}));
    (($tmp)->{bool} = Main::bool($MATCH));
    ($MATCH = $tmp);
    Main::bool($MATCH)
}) && (((do {
    ((my  $namespace = undef) = ("" . $MATCH->{'Perlito::Grammar.optional_namespace_before_ident'}));
    ((my  $name = undef) = ("" . $MATCH->{'Perlito::Grammar.ident'}));
    if (Main::bool($namespace)) {
        ($name = $namespace . '::' . $name)
    };
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, Proto->new(('name' => $name)) );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    ((((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'postfix_or_term' );
    push( @{$List_a}, 'funcall_no_params' );
    push( @{$List_a}, ("" . $MATCH->{'Perlito::Grammar.optional_namespace_before_ident'}) );
    push( @{$List_a}, ("" . $MATCH->{'Perlito::Grammar.ident'}) );
    $List_a
}))
}) || 1)))
}))
})))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->val_num($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.val_num'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.val_num'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->val_int($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.val_int'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.val_int'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->val_buf($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.val_buf'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'term' );
    push( @{$List_a}, ${$MATCH->{'Perlito::Grammar.val_buf'}} );
    $List_a
}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'space' );
    push( @{$List_a}, ' ' );
    $List_a
}))
}) || 1))))
}))
})));
            $MATCH
        };
        sub has_newline_after {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (((do {
    ((chr(35) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((do {
    ((my  $m2 = undef) = Perlito::Grammar->is_newline($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->space($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $m2 = undef) = $grammar->has_newline_after($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))
}))
})));
            $MATCH
        };
        sub has_no_comma_or_colon_after {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $tmp = undef) = $MATCH);
    ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1)));
    (($MATCH)->{bool} = (do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    ((my  $pos1 = undef) = $MATCH->to());
    ((do {
    ((',' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
}) || (do {
    (($MATCH)->{to} = $pos1);
    ((((':' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
}))
})
}));
    (($tmp)->{bool} = !Main::bool($MATCH));
    ($MATCH = $tmp);
    Main::bool($MATCH)
})) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))
})
})));
            $MATCH
        };
        sub list_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $expr = undef);
            ((my  $last_pos = undef) = $pos);
            ((my  $is_first_token = undef) = 1);
            ((my  $lexer_stack = undef) = do {
    (my  $List_a = []);
    (my  $List_v = []);
    $List_a
});
            ((my  $terminated = undef) = 0);
            ((my  $last_token_was_space = undef) = 1);
            ((my  $get_token = undef) = sub  {
    (my  $v = undef);
    if (Main::bool(scalar( @{$lexer_stack} ))) {
        ($v = pop( @{$lexer_stack} ));
        if (Main::bool((($is_first_token && (($v->[0] eq 'op'))) && !Main::bool((Perlito::Precedence::is_fixity_type('prefix', $v->[1])))))) {
            ($v->[0] = 'end')
        }
    }
    else {
        ((my  $m = undef) = $self->operator($str, $last_pos));
        if (Main::bool(!Main::bool($m))) {
            return scalar (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'end' );
    push( @{$List_a}, '*end*' );
    $List_a
})
        };
        ($v = ${$m});
        if (Main::bool((($is_first_token && (($v->[0] eq 'op'))) && !Main::bool((Perlito::Precedence::is_fixity_type('prefix', $v->[1])))))) {
            ($v->[0] = 'end')
        };
        if (Main::bool(($v->[0] ne 'end'))) {
            ($last_pos = $m->to())
        }
    };
    if (Main::bool(((((($v->[0]) eq 'postfix_or_term')) && ((($v->[1]) eq 'block'))) && $last_token_was_space))) {
        if (Main::bool($self->has_newline_after($str, $last_pos))) {
            ($terminated = 1);
            push( @{$lexer_stack}, do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'end' );
    push( @{$List_a}, '*end*' );
    $List_a
} )
        }
        else {
            if (Main::bool($self->has_no_comma_or_colon_after($str, $last_pos))) {
                ($terminated = 1);
                push( @{$lexer_stack}, do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'end' );
    push( @{$List_a}, '*end*' );
    $List_a
} )
            }
        }
    };
    ($last_token_was_space = (($v->[0] eq 'space')));
    ($is_first_token = 0);
    return scalar ($v)
});
            ((my  $prec = undef) = Perlito::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'and' );
    push( @{$List_a}, 'or' );
    push( @{$List_a}, chr(33) . chr(33) );
    push( @{$List_a}, chr(93) );
    push( @{$List_a}, chr(41) );
    push( @{$List_a}, chr(125) );
    push( @{$List_a}, chr(59) );
    push( @{$List_a}, 'if' );
    push( @{$List_a}, 'else' );
    push( @{$List_a}, 'elsif' );
    push( @{$List_a}, 'unless' );
    push( @{$List_a}, 'when' );
    push( @{$List_a}, 'for' );
    push( @{$List_a}, 'while' );
    push( @{$List_a}, 'loop' );
    $List_a
})));
            ((my  $res = undef) = $prec->precedence_parse());
            if (Main::bool((scalar( @{$res} ) == 0))) {
                return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => do {
    (my  $Hash_a = {});
    ($Hash_a->{'exp'} = '*undef*');
    ($Hash_a->{'end_block'} = undef);
    ($Hash_a->{'terminated'} = undef);
    $Hash_a
})))
            };
            (my  $block = undef);
            if (Main::bool((scalar( @{$res} ) > 1))) {
                ($block = pop( @{$res} ));
                ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
            };
            ((my  $result = undef) = pop_term($res));
            if (Main::bool((scalar( @{$res} ) > 0))) {
                ($block = pop( @{$res} ));
                ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
            };
            return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => do {
    (my  $Hash_a = {});
    ($Hash_a->{'exp'} = $result);
    ($Hash_a->{'end_block'} = $block);
    ($Hash_a->{'terminated'} = $terminated);
    $Hash_a
})))
        };
        sub circumfix_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            my $delimiter = $_[3];
            (my  $expr = undef);
            ((my  $last_pos = undef) = $pos);
            ((my  $get_token = undef) = sub  {
    ((my  $m = undef) = $self->operator($str, $last_pos));
    if (Main::bool(!Main::bool($m))) {
        die('Expected closing delimiter: ', (($delimiter) || []), ' near ', $last_pos)
    };
    ((my  $v = undef) = ${$m});
    if (Main::bool(($v->[0] ne 'end'))) {
        ($last_pos = $m->to())
    };
    return scalar ($v)
});
            ((my  $prec = undef) = Perlito::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => $delimiter)));
            ((my  $res = undef) = $prec->precedence_parse());
            ($res = pop_term($res));
            if (Main::bool(!Main::bool((defined($res))))) {
                ($res = '*undef*')
            };
            return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => $res)))
        };
        sub ternary_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            return scalar ($self->circumfix_parse($str, $pos, do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, chr(33) . chr(33) );
    $List_a
}))
        };
        sub curly_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            return scalar ($self->circumfix_parse($str, $pos, do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, chr(125) );
    $List_a
}))
        };
        sub square_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            return scalar ($self->circumfix_parse($str, $pos, do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, chr(93) );
    $List_a
}))
        };
        sub paren_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            return scalar ($self->circumfix_parse($str, $pos, do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, chr(41) );
    $List_a
}))
        };
        sub exp_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $expr = undef);
            ((my  $last_pos = undef) = $pos);
            ((my  $lexer_stack = undef) = do {
    (my  $List_a = []);
    (my  $List_v = []);
    $List_a
});
            ((my  $terminated = undef) = 0);
            ((my  $get_token = undef) = sub  {
    (my  $v = undef);
    if (Main::bool(scalar( @{$lexer_stack} ))) {
        ($v = pop( @{$lexer_stack} ))
    }
    else {
        ((my  $m = undef) = $self->operator($str, $last_pos));
        if (Main::bool(!Main::bool($m))) {
            return scalar (do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'end' );
    push( @{$List_a}, '*end*' );
    $List_a
})
        };
        ($v = ${$m});
        if (Main::bool(($v->[0] ne 'end'))) {
            ($last_pos = $m->to())
        }
    };
    if (Main::bool(((((((((($v->[0]) eq 'postfix_or_term')) && ((($v->[1]) eq 'block')))) || ((((($v->[0]) eq 'term')) && (Main::isa(($v->[1]), 'Sub'))))) || ((((($v->[0]) eq 'term')) && (Main::isa(($v->[1]), 'Method'))))) || ((((($v->[0]) eq 'term')) && (Main::isa(($v->[1]), 'Do'))))) || ((((($v->[0]) eq 'term')) && (Main::isa(($v->[1]), 'CompUnit'))))))) {
        if (Main::bool($self->has_newline_after($str, $last_pos))) {
            ($terminated = 1);
            push( @{$lexer_stack}, do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, 'end' );
    push( @{$List_a}, '*end*' );
    $List_a
} )
        }
    };
    return scalar ($v)
});
            ((my  $prec = undef) = Perlito::Precedence->new(('get_token' => $get_token), ('reduce' => $reduce_to_ast), ('end_token' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, chr(93) );
    push( @{$List_a}, chr(41) );
    push( @{$List_a}, chr(125) );
    push( @{$List_a}, chr(59) );
    push( @{$List_a}, 'if' );
    push( @{$List_a}, 'else' );
    push( @{$List_a}, 'elsif' );
    push( @{$List_a}, 'unless' );
    push( @{$List_a}, 'when' );
    push( @{$List_a}, 'for' );
    push( @{$List_a}, 'while' );
    push( @{$List_a}, 'loop' );
    $List_a
})));
            ((my  $res = undef) = $prec->precedence_parse());
            if (Main::bool((scalar( @{$res} ) == 0))) {
                return scalar (Perlito::Match->new(('bool' => 0)))
            };
            (my  $block = undef);
            if (Main::bool((scalar( @{$res} ) > 1))) {
                ($block = pop( @{$res} ));
                ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
            };
            ((my  $result = undef) = pop_term($res));
            if (Main::bool((scalar( @{$res} ) > 0))) {
                ($block = pop( @{$res} ));
                if (Main::bool(!Main::bool((Main::isa($block, 'Lit::Block'))))) {
                    ($block = Lit::Block->new(('stmts' => $block->[2]), ('sig' => $block->[3])))
                }
            };
            return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $last_pos), ('bool' => 1), ('capture' => do {
    (my  $Hash_a = {});
    ($Hash_a->{'exp'} = $result);
    ($Hash_a->{'end_block'} = $block);
    ($Hash_a->{'terminated'} = $terminated);
    $Hash_a
})))
        };
        sub exp_stmt {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    ((((((do {
    ((do {
    ((my  $m2 = undef) = Perlito::Grammar->if($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.if'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Grammar.if'}}))
}) || 1)))
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->unless($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.unless'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Grammar.unless'}}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->when($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.when'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Grammar.when'}}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->for($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.for'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Grammar.for'}}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->while($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.while'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Grammar.while'}}))
}) || 1))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((do {
    ((my  $m2 = undef) = Perlito::Grammar->loop($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'Perlito::Grammar.loop'} = $m2);
        1
    }
    else {
        0
    }
}) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'Perlito::Grammar.loop'}}))
}) || 1))))
}))
})));
            $MATCH
        };
        sub statement_modifier {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    ((((((do {
    (('if' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((('unless' eq substr($str, $MATCH->to(), 6)) && ((($MATCH)->{to} = (6 + $MATCH->to()))))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((('when' eq substr($str, $MATCH->to(), 4)) && ((($MATCH)->{to} = (4 + $MATCH->to()))))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((('for' eq substr($str, $MATCH->to(), 3)) && ((($MATCH)->{to} = (3 + $MATCH->to()))))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((('while' eq substr($str, $MATCH->to(), 5)) && ((($MATCH)->{to} = (5 + $MATCH->to()))))))
})) || (do {
    (($MATCH)->{to} = $pos1);
    (((('loop' eq substr($str, $MATCH->to(), 4)) && ((($MATCH)->{to} = (4 + $MATCH->to()))))))
}))
})));
            $MATCH
        };
        sub delimited_statement {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH = undef);
            ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1 = undef) = $MATCH->to());
    (do {
    ((do {
    ((my  $last_pos = undef) = $MATCH->to());
    if (Main::bool(!Main::bool((do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}) && (do {
    ((my  $pos1 = undef) = $MATCH->to());
    ((do {
    ((((chr(59) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do {
    ((my  $last_pos = undef) = $MATCH->to());
    if (Main::bool(!Main::bool((do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
}))
}) || (do {
    (($MATCH)->{to} = $pos1);
    (((((do {
    ((my  $m2 = undef) = $grammar->statement_parse($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        ($MATCH->{'statement_parse'} = $m2);
        1
    }
    else {
        0
    }
}) && (do {
    ((my  $last_pos = undef) = $MATCH->to());
    if (Main::bool(!Main::bool((do {
    ((chr(59) eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (do {
    ((my  $last_pos = undef) = $MATCH->to());
    if (Main::bool(!Main::bool((do {
    ((my  $m2 = undef) = Perlito::Grammar->ws($str, $MATCH->to()));
    if (Main::bool($m2)) {
        (($MATCH)->{to} = $m2->to());
        1
    }
    else {
        0
    }
})))) {
        (($MATCH)->{to} = $last_pos)
    };
    1
})) && (((do {
    ($MATCH->{capture} = (${$MATCH->{'statement_parse'}}))
}) || 1))))
}))
}))
})
})));
            $MATCH
        };
        sub statement_parse {
            my $self = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $expr = undef);
            ((my  $last_pos = undef) = $pos);
            ((my  $lexer_stack = undef) = do {
    (my  $List_a = []);
    (my  $List_v = []);
    $List_a
});
            (my  $res = undef);
            ($res = $self->exp_stmt($str, $pos));
            if (Main::bool($res)) {
                return scalar ($res)
            };
            ($res = $self->exp_parse($str, $pos));
            if (Main::bool(!Main::bool(($res)))) {
                return scalar ($res)
            };
            if (Main::bool(Main::isa((${$res})->{'exp'}, 'Lit::Block'))) {
                ((${$res})->{'exp'} = Do->new(('block' => (${$res})->{'exp'})))
            };
            if (Main::bool((${$res})->{'end_block'})) {
                die('Unexpected block after expression near ', $pos)
            };
            if (Main::bool((${$res})->{'terminated'})) {
                (($res)->{capture} = (${$res})->{'exp'});
                return scalar ($res)
            };
            ((my  $modifier = undef) = $self->statement_modifier($str, $res->to()));
            if (Main::bool(!Main::bool(($modifier)))) {
                (($res)->{capture} = (${$res})->{'exp'});
                return scalar ($res)
            };
            ((my  $modifier_exp = undef) = $self->exp_parse($str, $modifier->to()));
            if (Main::bool(!Main::bool(($modifier_exp)))) {
                die('Expected expression after ' . chr(39), $modifier, chr(39))
            };
            if (Main::bool((${$modifier_exp})->{'end_block'})) {
                die('Unexpected block after expression near ', $modifier->to())
            };
            ($modifier = ("" . $modifier));
            if (Main::bool(($modifier eq 'if'))) {
                return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => If->new(('cond' => (${$modifier_exp})->{'exp'}), ('body' => Lit::Block->new(('stmts' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, (${$res})->{'exp'} );
    $List_a
}))), ('otherwise' => Lit::Block->new(('stmts' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    $List_a
})))))))
            };
            if (Main::bool(($modifier eq 'unless'))) {
                return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => If->new(('cond' => (${$modifier_exp})->{'exp'}), ('body' => Lit::Block->new(('stmts' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    $List_a
}))), ('otherwise' => Lit::Block->new(('stmts' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, (${$res})->{'exp'} );
    $List_a
})))))))
            };
            if (Main::bool(($modifier eq 'while'))) {
                return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => While->new(('cond' => (${$modifier_exp})->{'exp'}), ('body' => Lit::Block->new(('stmts' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, (${$res})->{'exp'} );
    $List_a
})))))))
            };
            if (Main::bool(($modifier eq 'for'))) {
                return scalar (Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $modifier_exp->to()), ('bool' => 1), ('capture' => For->new(('cond' => (${$modifier_exp})->{'exp'}), ('body' => Lit::Block->new(('stmts' => do {
    (my  $List_a = []);
    (my  $List_v = []);
    push( @{$List_a}, (${$res})->{'exp'} );
    $List_a
})))))))
            };
            die('Unexpected statement modifier ' . chr(39) . $modifier . chr(39))
        }
    }


}

1;
