# Do not edit this file - Generated by Perlito 6.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito::Perl5::Runtime;
use Perlito::Perl5::Prelude;
our $MATCH = Perlito::Match->new();
{
package GLOBAL;
sub new { shift; bless { @_ }, "GLOBAL" }

# use v6 
;
{
package Lit::Array;
sub new { shift; bless { @_ }, "Lit::Array" }
sub array1 { $_[0]->{array1} };
sub expand_interpolation { my $self = $_[0]; ((my  $needs_interpolation = undef) = 0); (my  $List_items = []); for my $item ( @{$self->{array1} || []} ) { if (Main::bool((Main::isa($item, 'Apply') && ((($item->code() eq 'circumfix:<( )>') || ($item->code() eq 'list:<,>')))))) { for my $arg ( @{(($item->arguments()) || []) || []} ) { push( @{$List_items}, $arg ) } } else { push( @{$List_items}, $item ) } }; for my $item ( @{$List_items || []} ) { if (Main::bool(((Main::isa($item, 'Var') && ($item->sigil() eq '@')) || (Main::isa($item, 'Apply') && ((($item->code() eq 'prefix:<@>') || ($item->code() eq 'infix:<..>'))))))) { ($needs_interpolation = 1) }  }; if (Main::bool(($needs_interpolation && (scalar( @{$List_items} ) == 1)))) { return scalar ($List_items->[0]) } ; (my  $List_s = []); for my $item ( @{$List_items || []} ) { if (Main::bool(((Main::isa($item, 'Var') && ($item->sigil() eq '@')) || (Main::isa($item, 'Apply') && ((($item->code() eq 'prefix:<@>') || ($item->code() eq 'infix:<..>'))))))) { push( @{$List_s}, Apply->new(('arguments' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Var->new(('name' => 'v'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => '')) ); push( @{$List_a}, $item ); $List_a }), ('code' => 'infix:<=>'), ('namespace' => '')) ); push( @{$List_s}, For->new(('body' => Lit::Block->new(('sig' => Var->new(('name' => 'x'), ('namespace' => ''), ('sigil' => '$'), ('twigil' => ''))), ('stmts' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Call->new(('arguments' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Index->new(('index_exp' => Var->new(('name' => 'x'), ('namespace' => ''), ('sigil' => '$'), ('twigil' => ''))), ('obj' => Var->new(('name' => 'v'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => '')))) ); $List_a }), ('hyper' => ''), ('invocant' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => ''))), ('method' => 'push')) ); $List_a }))), ('cond' => Apply->new(('arguments' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Val::Int->new(('int' => 0)) ); push( @{$List_a}, Apply->new(('arguments' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Apply->new(('arguments' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Call->new(('arguments' => do { (my  $List_a = []); (my  $List_v = []); $List_a }), ('hyper' => ''), ('invocant' => Var->new(('name' => 'v'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => ''))), ('method' => 'elems')) ); push( @{$List_a}, Val::Int->new(('int' => 1)) ); $List_a }), ('code' => 'infix:<->'), ('namespace' => '')) ); $List_a }), ('code' => 'circumfix:<( )>'), ('namespace' => '')) ); $List_a }), ('code' => 'infix:<..>'), ('namespace' => ''))), ('topic' => undef)) ) } else { push( @{$List_s}, Call->new(('arguments' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, $item ); $List_a }), ('hyper' => ''), ('invocant' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => ''))), ('method' => 'push')) ) } }; return scalar (Do->new(('block' => Lit::Block->new(('sig' => undef), ('stmts' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Decl->new(('decl' => 'my'), ('type' => ''), ('var' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => '')))) ); push( @{$List_a}, Decl->new(('decl' => 'my'), ('type' => ''), ('var' => Var->new(('name' => 'v'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => '')))) ); ($List_v = $List_s); for my $x ( @{[0 .. ((scalar( @{$List_v} ) - 1))] || []} ) { push( @{$List_a}, $List_v->[$x] ) }; push( @{$List_a}, Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => '@'), ('twigil' => '')) ); $List_a }))))) }
}

;
{
package Lit::Hash;
sub new { shift; bless { @_ }, "Lit::Hash" }
sub hash1 { $_[0]->{hash1} };
sub expand_interpolation { my $self = $_[0]; (my  $List_items = []); for my $item ( @{$self->{hash1} || []} ) { if (Main::bool((Main::isa($item, 'Apply') && ((($item->code() eq 'circumfix:<( )>') || ($item->code() eq 'list:<,>')))))) { for my $arg ( @{(($item->arguments()) || []) || []} ) { push( @{$List_items}, $arg ) } } else { push( @{$List_items}, $item ) } }; (my  $List_s = []); for my $item ( @{$List_items || []} ) { if (Main::bool((Main::isa($item, 'Apply') && ($item->code() eq 'infix:<=>>')))) { push( @{$List_s}, Apply->new(('arguments' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Lookup->new(('index_exp' => $item->arguments()->[0]), ('obj' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => '%'), ('twigil' => '')))) ); push( @{$List_a}, $item->arguments()->[1] ); $List_a }), ('code' => 'infix:<=>'), ('namespace' => '')) ) } else { if (Main::bool(((Main::isa($item, 'Var') && ($item->sigil() eq '%')) || (Main::isa($item, 'Apply') && ($item->code() eq 'prefix:<%>'))))) { push( @{$List_s}, For->new(('body' => Lit::Block->new(('sig' => Var->new(('name' => 'p'), ('namespace' => ''), ('sigil' => '$'), ('twigil' => ''))), ('stmts' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Apply->new(('arguments' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Lookup->new(('index_exp' => Call->new(('arguments' => undef), ('hyper' => ''), ('invocant' => Var->new(('name' => 'p'), ('namespace' => ''), ('sigil' => '$'), ('twigil' => ''))), ('method' => 'key'))), ('obj' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => '%'), ('twigil' => '')))) ); push( @{$List_a}, Call->new(('arguments' => do { (my  $List_a = []); (my  $List_v = []); $List_a }), ('hyper' => ''), ('invocant' => Var->new(('name' => 'p'), ('namespace' => ''), ('sigil' => '$'), ('twigil' => ''))), ('method' => 'value')) ); $List_a }), ('code' => 'infix:<=>'), ('namespace' => '')) ); $List_a }))), ('cond' => Apply->new(('arguments' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Apply->new(('arguments' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Call->new(('arguments' => undef), ('hyper' => ''), ('invocant' => $item), ('method' => 'pairs')) ); $List_a }), ('code' => 'circumfix:<( )>'), ('namespace' => '')) ); $List_a }), ('code' => 'prefix:<@>'), ('namespace' => ''))), ('topic' => undef)) ) } else { die('Error in hash composer: ', Main::perl($item, )) } } }; return scalar (Do->new(('block' => Lit::Block->new(('sig' => undef), ('stmts' => do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, Decl->new(('decl' => 'my'), ('type' => ''), ('var' => Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => '%'), ('twigil' => '')))) ); ($List_v = $List_s); for my $x ( @{[0 .. ((scalar( @{$List_v} ) - 1))] || []} ) { push( @{$List_a}, $List_v->[$x] ) }; push( @{$List_a}, Var->new(('name' => 'a'), ('namespace' => ''), ('sigil' => '%'), ('twigil' => '')) ); $List_a }))))) }
}


}

1;
