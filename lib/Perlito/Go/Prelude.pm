# Do not edit this file - Generated by Perlito 6.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito::Perl5::Runtime;
our $MATCH = Perlito::Match->new();
{
package GLOBAL;
sub new { shift; bless { @_ }, "GLOBAL" }

# use v6 
;
{
package Perlito::Match;
sub new { shift; bless { @_ }, "Perlito::Match" }
sub from { $_[0]->{from} };
sub to { $_[0]->{to} };
sub str { $_[0]->{str} };
sub bool { $_[0]->{bool} };
sub capture { $_[0]->{capture} };
sub hash { $_[0]->{hash} };
sub array { $_[0]->{array} };
sub perl { my $self = $_[0]; return('Match.new(' . 'from => ' . Main::perl($self->{from}, ("" . ', to => ') . Main::perl($self->{to}, ("" . ', bool => ') . Main::perl(($self->{bool}->bool()), ("" . ', capture => ') . Main::perl($self->{capture}, ("" . ', hash => ') . Main::perl($self->{hash}, ("" . ', array => ') . Main::perl($self->{array}, ("" . ')')))))))) };
sub Bool { my $self = $_[0]; $self->{bool}->Bool() };
sub Str { my $self = $_[0]; die('TODO') };
sub scalar { my $self = $_[0]; die('TODO') };
sub exists { my $self = $_[0]; die('TODO') }
}

;
{
package Perlito::Grammar;
sub new { shift; bless { @_ }, "Perlito::Grammar" }
sub is_newline { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('' ne substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) } }))); $MATCH };
sub word { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('' ne substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) } }))); $MATCH };
sub digit { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('' ne substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) } }))); $MATCH };
sub not_newline { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('' ne substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) } }))); $MATCH };
sub space { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('' ne substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) } }))); $MATCH }
}

;
{
package IO;
sub new { shift; bless { @_ }, "IO" }
sub slurp { die('stub') }
}

;
{
package Main;
sub new { shift; bless { @_ }, "Main" }
sub newline { my $self = $_[0]; '
' };
sub to_lisp_identifier { my $ident = $_[0]; return('sv-' . $ident) };
sub lisp_dump_object { my $class_name = $_[0]; my $data = $_[1]; return($class_name . '( ' . Main::join(([ map { Main::perl( $_, , ) } @{ $data } ]), ', ') . ' )') };
sub to_go_namespace { die('TODO') };
sub to_javascript_namespace { die('TODO') };
sub javascript_escape_string { die('TODO') };
sub to_lisp_namespace { die('TODO') };
sub lisp_escape_string { die('TODO') };
sub perl_escape_string { die('TODO') }
}


}

1;
