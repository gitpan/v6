# Do not edit this file - Generated by Perlito 7.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito::Perl5::Runtime;
use Perlito::Perl5::Prelude;
our $MATCH = Perlito::Match->new();
{
package GLOBAL;
    sub new { shift; bless { @_ }, "GLOBAL" }

    # use v6 
;
    {
    package Perlito::Go::LexicalBlock;
        sub new { shift; bless { @_ }, "Perlito::Go::LexicalBlock" }
        sub block { $_[0]->{block} };
        sub needs_return { $_[0]->{needs_return} };
        sub top_level { $_[0]->{top_level} };
        sub emit_go {
            my $self = $_[0];
            if (!(($self->{block}))) {
                return scalar ('')
            };
            ((my  $str) = '');
            (my  $Hash_decl_seen = bless {}, 'HASH');
            for my $decl1 ( @{$self->{block}} ) {
                ((my  $decl) = $decl1);
                if (((Main::isa($decl, 'Bind') && Main::isa(($decl->parameters()), 'Decl')) && ((($decl->parameters())->decl() eq 'my')))) {
                    ($decl = $decl->parameters())
                };
                if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'my')))) {
                    ((my  $var_name) = (($decl)->var())->emit_go());
                    if (!(($Hash_decl_seen->{$var_name}))) {
                        ($str = ($str . $decl->emit_go_init()));
                        ($Hash_decl_seen->{$var_name} = 1)
                    }
                }
            };
            (my  $last_statement);
            if ($self->{needs_return}) {
                ($last_statement = pop( @{$self->{block}} ))
            };
            for my $decl ( @{$self->{block}} ) {
                if ((!(((Main::isa($decl, 'Decl') && (($decl->decl() eq 'my'))))))) {
                    ($str = ($str . ($decl)->emit_go() . chr(59)))
                }
            };
            if (($self->{needs_return} && $last_statement)) {
                if (Main::isa($last_statement, 'If')) {
                    ((my  $cond) = $last_statement->cond());
                    ((my  $body) = $last_statement->body());
                    ((my  $otherwise) = $last_statement->otherwise());
                    if ((Main::isa($cond, 'Apply') && ($cond->code() eq 'prefix:<' . chr(33) . '>'))) {
                        ($cond = ($cond->arguments())->[0]);
                        ($body = $last_statement->otherwise());
                        ($otherwise = $last_statement->body())
                    };
                    if ((Main::isa($cond, 'Var') && ($cond->sigil() eq chr(64)))) {
                        ($cond = Apply->new(('code' => 'prefix:<' . chr(64) . '>'), ('arguments' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $cond );
    $List_a
})))
                    };
                    ($body = Perlito::Go::LexicalBlock->new(('block' => $body), ('needs_return' => 1), ('top_level' => $self->{top_level})));
                    ($otherwise = Perlito::Go::LexicalBlock->new(('block' => $otherwise), ('needs_return' => 1), ('top_level' => $self->{top_level})));
                    ($str = ($str . 'if tobool( ' . Call::emit_go_call($cond, 'Bool') . ' ) ' . chr(123) . ' ' . $body->emit_go() . ' ' . chr(125) . ' else ' . chr(123) . ' ' . $otherwise->emit_go() . ' ' . chr(125)))
                }
                else {
                    if ((Main::isa($last_statement, 'Return') || Main::isa($last_statement, 'For'))) {
                        ($str = ($str . $last_statement->emit_go()))
                    }
                    else {
                        ($last_statement = Return->new(('result' => $last_statement)));
                        if ($self->{top_level}) {
                            ($str = ($str . $last_statement->emit_go()))
                        }
                        else {
                            ($str = ($str . $last_statement->emit_go_simple()))
                        }
                    }
                }
            };
            return scalar ($str)
        }
    }

;
    {
    package CompUnit;
        sub new { shift; bless { @_ }, "CompUnit" }
        sub name { $_[0]->{name} };
        sub attributes { $_[0]->{attributes} };
        sub methods { $_[0]->{methods} };
        sub body { $_[0]->{body} };
        sub emit_go {
            my $self = $_[0];
            ((my  $class_name) = Main::to_go_namespace($self->{name}));
            ((my  $str) = (chr(47) . chr(47) . ' instances of class ' . $self->{name} . (chr(10)) . 'type ' . $class_name . ' struct ' . chr(123) . (chr(10))));
            for my $decl ( @{((Main::values(($self->{attributes}), )))} ) {
                if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'has')))) {
                    ($str = ($str . '  ' . 'v_' . ($decl->var())->name() . ' *Any' . chr(59) . (chr(10))))
                }
            };
            ($str = ($str . chr(125) . (chr(10))));
            ($str = ($str . chr(47) . chr(47) . ' methods in class ' . $self->{name} . (chr(10)) . 'var Method_' . $class_name . ' struct ' . chr(123) . (chr(10))));
            for my $decl ( @{((Main::values(($self->{methods}), )))} ) {
                if (Main::isa($decl, 'Method')) {
                    ($str = ($str . '  ' . 'f_' . $decl->name() . ' func (*' . $class_name . ', Capture) *Any' . chr(59) . (chr(10))))
                }
            };
            for my $decl ( @{((Main::values(($self->{attributes}), )))} ) {
                if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'has')))) {
                    ($str = ($str . '  ' . 'f_' . ($decl->var())->name() . ' func (*' . $class_name . ', Capture) *Any' . chr(59) . (chr(10))))
                }
            };
            ($str = ($str . chr(125) . (chr(10))));
            ($str = ($str . chr(47) . chr(47) . ' namespace ' . $self->{name} . (chr(10)) . 'var Namespace_' . $class_name . ' struct ' . chr(123) . (chr(10))));
            for my $decl ( @{$self->{body}} ) {
                if (Main::isa($decl, 'Sub')) {
                    ($str = ($str . '  ' . 'f_' . $decl->name() . ' Function' . chr(59) . (chr(10))))
                }
            };
            ($str = ($str . chr(125) . (chr(10))));
            ($str = ($str . 'var Run_' . $class_name . ' func ()' . chr(59) . (chr(10))));
            ($str = ($str . chr(47) . chr(47) . ' method wrappers for ' . $self->{name} . (chr(10))));
            for my $decl ( @{((Main::values(($self->{methods}), )))} ) {
                if (Main::isa($decl, 'Method')) {
                    ($str = ($str . 'func (v_self *' . $class_name . ') f_' . $decl->name() . ' (v Capture) *Any ' . chr(123) . (chr(10)) . '  return Method_' . $class_name . '.f_' . $decl->name() . '(v_self, v)' . chr(59) . (chr(10)) . chr(125) . (chr(10))))
                }
            };
            for my $decl ( @{((Main::values(($self->{attributes}), )))} ) {
                if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'has')))) {
                    ($str = ($str . 'func (v_self *' . $class_name . ') f_' . ($decl->var())->name() . ' (v Capture) *Any ' . chr(123) . (chr(10)) . '  return Method_' . $class_name . '.f_' . ($decl->var())->name() . '(v_self, v)' . chr(59) . (chr(10)) . chr(125) . (chr(10))))
                }
            };
            if (!((($self->{methods})->{'isa'}))) {
                ($str = ($str . 'func (v_self *' . $class_name . ') f_isa (v Capture) *Any ' . chr(123) . ' ' . 'return toBool( ' . chr(34) . $self->{name} . chr(34) . ' ' . chr(61) . chr(61) . ' tostr( v.p[0] ) ) ' . chr(125) . (chr(10))))
            };
            if (!((($self->{methods})->{'perl'}))) {
                ($str = ($str . 'func (v_self *' . $class_name . ') f_perl (v Capture) *Any ' . chr(123) . ' ' . 'return toStr( ' . chr(34) . '::' . $self->{name} . '(' . chr(34) . ' '));
                ((my  $sep) = '');
                for my $decl ( @{((Main::values(($self->{attributes}), )))} ) {
                    if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'has')))) {
                        ($str = ($str . $sep . '+ ' . chr(34) . ($decl->var())->name() . ' ' . chr(61) . '> ' . chr(34) . '+ tostr((*(*v_self).f_' . ($decl->var())->name() . '(Capture' . chr(123) . chr(125) . ')).(perl_er).f_perl(Capture' . chr(123) . chr(125) . ')) '));
                        ($sep = '+ ' . chr(34) . ', ' . chr(34) . ' ')
                    }
                };
                ($str = ($str . '+ ' . chr(34) . ')' . chr(34) . ' ) ' . chr(125) . (chr(10))))
            };
            if (((!((($self->{methods})->{'Bool'}))) && (!((($self->{attributes})->{'Bool'}))))) {
                ($str = ($str . 'func (v_self *' . $class_name . ') f_Bool (v Capture) *Any ' . chr(123) . ' ' . 'return b_true() ' . chr(125) . (chr(10))))
            };
            ($str = ($str . chr(47) . chr(47) . ' prototype of ' . $self->{name} . (chr(10)) . 'var Proto_' . $class_name . ' *Any' . chr(59) . (chr(10))));
            ($str = ($str . 'func Init_' . $class_name . '() ' . chr(123) . (chr(10))));
            ($str = ($str . '  this_namespace :' . chr(61) . ' ' . chr(38) . 'Namespace_' . $class_name . chr(59) . (chr(10)) . '  this_namespace ' . chr(61) . ' this_namespace' . chr(59) . (chr(10))));
            ($str = ($str . '  Proto_' . $class_name . ' ' . chr(61) . ' ' . 'func() *Any ' . chr(123) . ' ' . 'var m ' . chr(61) . ' new(' . $class_name . ')' . chr(59) . ' ' . 'var m1 Any ' . chr(61) . ' m' . chr(59) . ' ' . 'return ' . chr(38) . 'm1' . chr(59) . ' ' . chr(125) . '()' . chr(59) . (chr(10))));
            (my  $Hash_decl_seen = bless {}, 'HASH');
            for my $decl1 ( @{$self->{body}} ) {
                ((my  $decl) = $decl1);
                if (((Main::isa($decl, 'Bind') && Main::isa(($decl->parameters()), 'Decl')) && ((($decl->parameters())->decl() eq 'my')))) {
                    ($decl = $decl->parameters())
                };
                if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'my')))) {
                    ((my  $var_name) = (($decl)->var())->emit_go());
                    if (!(($Hash_decl_seen->{$var_name}))) {
                        ($str = ($str . $decl->emit_go_init()));
                        ($Hash_decl_seen->{$var_name} = 1)
                    }
                }
            };
            for my $decl ( @{$self->{body}} ) {
                if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'has')))) {
                    ($str = ($str . '  ' . chr(47) . chr(47) . ' accessor ' . ($decl->var())->name() . (chr(10)) . '  Method_' . $class_name . '.f_' . ($decl->var())->name() . ' ' . chr(61) . ' func (v_self *' . $class_name . ', v Capture) *Any ' . chr(123) . (chr(10))));
                    ($str = ($str . '    ' . 'if v_self.v_' . ($decl->var())->name() . ' ' . chr(61) . chr(61) . ' nil ' . chr(123) . (chr(10)) . '      ' . (Decl->new(('decl' => 'my'), ('type' => undef()), ('var' => Var->new(('sigil' => ($decl->var())->sigil()), ('twigil' => ''), ('namespace' => ''), ('name' => 'tmp')))))->emit_go_init() . '      ' . 'v_self.v_' . ($decl->var())->name() . ' ' . chr(61) . ' ' . (Var->new(('sigil' => ($decl->var())->sigil()), ('twigil' => ''), ('namespace' => ''), ('name' => 'tmp')))->emit_go() . chr(59) . (chr(10)) . '    ' . chr(125) . (chr(10))));
                    ($str = ($str . '    ' . 'if *v_self.v_' . ($decl->var())->name() . ' ' . chr(61) . chr(61) . ' nil ' . chr(123) . (chr(10)) . '      ' . (Decl->new(('decl' => 'my'), ('type' => undef()), ('var' => Var->new(('sigil' => ($decl->var())->sigil()), ('twigil' => ''), ('namespace' => ''), ('name' => 'tmp')))))->emit_go_init() . '      ' . 'v_self.v_' . ($decl->var())->name() . ' ' . chr(61) . ' ' . (Var->new(('sigil' => ($decl->var())->sigil()), ('twigil' => ''), ('namespace' => ''), ('name' => 'tmp')))->emit_go() . chr(59) . (chr(10)) . '    ' . chr(125) . (chr(10))));
                    ($str = ($str . '    ' . 'return v_self.v_' . ($decl->var())->name() . (chr(10)) . '  ' . chr(125) . chr(59) . (chr(10))))
                };
                if (Main::isa($decl, 'Method')) {
                    ((my  $sig) = $decl->sig());
                    ((my  $block) = Perlito::Go::LexicalBlock->new(('block' => $decl->block()), ('needs_return' => 1), ('top_level' => 1)));
                    ($str = ($str . '  ' . chr(47) . chr(47) . ' method ' . $decl->name() . (chr(10)) . '  Method_' . $class_name . '.f_' . $decl->name() . ' ' . chr(61) . ' func (self *' . $class_name . ', v Capture) *Any ' . chr(123) . (chr(10))));
                    ($str = ($str . '    var self1 Any ' . chr(61) . ' self' . chr(59) . (chr(10)) . '    var ' . ($sig->invocant())->emit_go() . ' *Any ' . chr(61) . ' ' . chr(38) . 'self1' . chr(59) . (chr(10)) . '    ' . ($sig->invocant())->emit_go() . ' ' . chr(61) . ' ' . ($sig->invocant())->emit_go() . chr(59) . (chr(10)) . '    ' . $sig->emit_go_bind() . (chr(10))));
                    ($str = ($str . '    p :' . chr(61) . ' make(chan *Any)' . chr(59) . ' go func () ' . chr(123) . ' ' . (chr(10)) . '        ' . $block->emit_go() . chr(59) . ' p <- nil ' . chr(125) . '()' . chr(59) . ' ' . (chr(10)) . '    return <-p' . chr(59) . ' ' . (chr(10)) . '  ' . chr(125) . chr(59) . (chr(10))))
                };
                if (Main::isa($decl, 'Sub')) {
                    ((my  $sig) = $decl->sig());
                    ((my  $block) = Perlito::Go::LexicalBlock->new(('block' => $decl->block()), ('needs_return' => 1), ('top_level' => 1)));
                    ($str = ($str . '  ' . chr(47) . chr(47) . ' sub ' . $decl->name() . (chr(10)) . '  Namespace_' . $class_name . '.f_' . $decl->name() . ' ' . chr(61) . ' Function( func (v Capture) *Any ' . chr(123) . (chr(10))));
                    ($str = ($str . '    ' . $sig->emit_go_bind() . (chr(10)) . '    p :' . chr(61) . ' make(chan *Any)' . chr(59) . ' go func () ' . chr(123) . ' ' . (chr(10)) . '        ' . $block->emit_go() . chr(59) . ' p <- nil ' . chr(125) . '()' . chr(59) . ' ' . (chr(10))));
                    ($str = ($str . '    return <-p' . chr(59) . ' ' . (chr(10)) . '  ' . chr(125) . ' )' . chr(59) . (chr(10))))
                }
            };
            ($str = ($str . '  ' . chr(47) . chr(47) . ' main runtime block of ' . $self->{name} . (chr(10)) . '  Run_' . $class_name . ' ' . chr(61) . ' func () ' . chr(123) . (chr(10))));
            for my $decl ( @{$self->{body}} ) {
                if ((((!(((Main::isa($decl, 'Decl') && (((($decl->decl() eq 'has')) || (($decl->decl() eq 'my')))))))) && (!((Main::isa($decl, 'Method'))))) && (!((Main::isa($decl, 'Sub')))))) {
                    ($str = ($str . '    ' . ($decl)->emit_go() . chr(59) . (chr(10))))
                }
            };
            ($str = ($str . '  ' . chr(125) . (chr(10))));
            ($str = ($str . chr(125) . (chr(10))));
            return scalar ($str)
        };
        sub emit_go_program {
            my $comp_units = $_[0];
            ((my  $str) = '');
            (my  $Hash_unit_seen = bless {}, 'HASH');
            (my  $List_tmp_comp_unit = bless [], 'ARRAY');
            for my $comp_unit ( @{(($comp_units))} ) {
                ((my  $name) = $comp_unit->name());
                if ($Hash_unit_seen->{$name}) {
                    for my $stmt ( @{(($comp_unit->body()))} ) {
                        push( @{($Hash_unit_seen->{$name})->body()}, $stmt )
                    }
                }
                else {
                    ($Hash_unit_seen->{$name} = $comp_unit);
                    push( @{$List_tmp_comp_unit}, $comp_unit )
                }
            };
            ($comp_units = $List_tmp_comp_unit);
            for my $comp_unit ( @{(($comp_units))} ) {
                for my $stmt ( @{(($comp_unit->body()))} ) {
                    if (Main::isa($stmt, 'Method')) {
                        (($comp_unit->methods())->{$stmt->name()} = $stmt)
                    };
                    if ((Main::isa($stmt, 'Decl') && (($stmt->decl() eq 'has')))) {
                        (($comp_unit->attributes())->{($stmt->var())->name()} = $stmt)
                    }
                }
            };
            for my $comp_unit ( @{(($comp_units))} ) {
                ($str = ($str . $comp_unit->emit_go()))
            };
            if (!(($Hash_unit_seen->{('Perlito::Grammar')}))) {
                ($str = ($str . ('type Perlito__Grammar struct' . chr(123) . chr(125) . chr(10))))
            };
            ($str = ($str . (chr(47) . chr(47) . ' interfaces for all methods' . chr(10))));
            ((my  $Hash_meth_seen = bless {}, 'HASH') = do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{'join'} = 1);
    ($Hash_a->{'perl'} = 1);
    ($Hash_a->{'scalar'} = 1);
    ($Hash_a->{'isa'} = 1);
    ($Hash_a->{'values'} = 1);
    ($Hash_a->{'keys'} = 1);
    ($Hash_a->{'exists'} = 1);
    ($Hash_a->{'bind'} = 1);
    ($Hash_a->{'int'} = 1);
    ($Hash_a->{'num'} = 1);
    ($Hash_a->{'str'} = 1);
    ($Hash_a->{'Str'} = 1);
    ($Hash_a->{'bool'} = 1);
    ($Hash_a->{'Bool'} = 1);
    ($Hash_a->{'array'} = 1);
    ($Hash_a->{'hash'} = 1);
    ($Hash_a->{'push'} = 1);
    ($Hash_a->{'pop'} = 1);
    ($Hash_a->{'shift'} = 1);
    ($Hash_a->{'lookup'} = 1);
    ($Hash_a->{'index'} = 1);
    ($Hash_a->{'function'} = 1);
    $Hash_a
});
            for my $comp_unit ( @{(($comp_units))} ) {
                for my $stmt ( @{(($comp_unit->body()))} ) {
                    if ((Main::isa($stmt, 'Method') && !(($Hash_meth_seen->{$stmt->name()})))) {
                        ((my  $meth) = $stmt->name());
                        ($str = ($str . ('type ') . $meth . ('_er interface ' . chr(123) . ' f_') . $meth . (' (Capture) *Any ' . chr(125) . chr(10))));
                        ($Hash_meth_seen->{$meth} = 1)
                    };
                    if (((Main::isa($stmt, 'Decl') && (($stmt->decl() eq 'has'))) && !(($Hash_meth_seen->{($stmt->var())->name()})))) {
                        ((my  $meth) = ($stmt->var())->name());
                        ($str = ($str . ('type ') . $meth . ('_er interface ' . chr(123) . ' f_') . $meth . (' (Capture) *Any ' . chr(125) . chr(10))));
                        ($Hash_meth_seen->{$meth} = 1)
                    }
                }
            };
            ($str = ($str . (chr(10)) . ('func main () ' . chr(123) . chr(10)) . ('  Init_Perlito__Match()' . chr(59) . chr(10))));
            for my $comp_unit ( @{(($comp_units))} ) {
                ($str = ($str . ('  Init_') . Main::to_go_namespace($comp_unit->name()) . ('()' . chr(59) . chr(10))))
            };
            ($str = ($str . ('  Init_Prelude()' . chr(59) . chr(10))));
            for my $comp_unit ( @{(($comp_units))} ) {
                ($str = ($str . ('  Run_') . Main::to_go_namespace($comp_unit->name()) . ('()' . chr(59) . chr(10))))
            };
            ($str = ($str . chr(125) . (chr(10))));
            return scalar ($str)
        }
    }

;
    {
    package Val::Int;
        sub new { shift; bless { @_ }, "Val::Int" }
        sub int { $_[0]->{int} };
        sub emit_go {
            my $self = $_[0];
            ('toInt(' . $self->{int} . ')')
        }
    }

;
    {
    package Val::Bit;
        sub new { shift; bless { @_ }, "Val::Bit" }
        sub bit { $_[0]->{bit} };
        sub emit_go {
            my $self = $_[0];
            ($self->{bit} ? 'b_true()' : 'b_false()')
        }
    }

;
    {
    package Val::Num;
        sub new { shift; bless { @_ }, "Val::Num" }
        sub num { $_[0]->{num} };
        sub emit_go {
            my $self = $_[0];
            ('toNum(' . $self->{num} . ')')
        }
    }

;
    {
    package Val::Buf;
        sub new { shift; bless { @_ }, "Val::Buf" }
        sub buf { $_[0]->{buf} };
        sub emit_go {
            my $self = $_[0];
            ('toStr(' . chr(34) . $self->{buf} . chr(34) . ')')
        }
    }

;
    {
    package Val::Undef;
        sub new { shift; bless { @_ }, "Val::Undef" }
        sub emit_go {
            my $self = $_[0];
            'u_undef()'
        }
    }

;
    {
    package Val::Object;
        sub new { shift; bless { @_ }, "Val::Object" }
        sub class { $_[0]->{class} };
        sub fields { $_[0]->{fields} };
        sub emit_go {
            my $self = $_[0];
            die('Val::Object - not used yet')
        }
    }

;
    {
    package Lit::Array;
        sub new { shift; bless { @_ }, "Lit::Array" }
        sub array1 { $_[0]->{array1} };
        sub emit_go {
            my $self = $_[0];
            ((my  $ast) = $self->expand_interpolation());
            return scalar ($ast->emit_go())
        }
    }

;
    {
    package Lit::Hash;
        sub new { shift; bless { @_ }, "Lit::Hash" }
        sub hash1 { $_[0]->{hash1} };
        sub emit_go {
            my $self = $_[0];
            ((my  $ast) = $self->expand_interpolation());
            return scalar ($ast->emit_go())
        }
    }

;
    {
    package Lit::Code;
        sub new { shift; bless { @_ }, "Lit::Code" }

    }

;
    {
    package Lit::Object;
        sub new { shift; bless { @_ }, "Lit::Object" }
        sub class { $_[0]->{class} };
        sub fields { $_[0]->{fields} };
        sub emit_go {
            my $self = $_[0];
            ((my  $fields) = $self->{fields});
            ((my  $str) = '');
            for my $field ( @{($fields)} ) {
                ($str = ($str . 'if m.v_' . ($field->[0])->buf() . ' ' . chr(61) . chr(61) . ' nil ' . chr(123) . (chr(10)) . 'var p Any' . chr(59) . ' ' . (chr(10)) . 'm.v_' . ($field->[0])->buf() . ' ' . chr(61) . ' ' . chr(38) . 'p' . chr(59) . ' ' . (chr(10)) . chr(125) . (chr(10)) . '*m.v_' . ($field->[0])->buf() . ' ' . chr(61) . ' *' . ($field->[1])->emit_go() . chr(59) . ' ' . (chr(10))))
            };
            ('func() *Any ' . chr(123) . ' ' . (chr(10)) . '  var m ' . chr(61) . ' new(' . Main::to_go_namespace($self->{class}) . ')' . chr(59) . ' ' . (chr(10)) . '  ' . $str . (chr(10)) . '  var m1 Any ' . chr(61) . ' m' . chr(59) . ' ' . (chr(10)) . '  return ' . chr(38) . 'm1' . chr(59) . ' ' . (chr(10)) . chr(125) . '()')
        }
    }

;
    {
    package Index;
        sub new { shift; bless { @_ }, "Index" }
        sub obj { $_[0]->{obj} };
        sub index_exp { $_[0]->{index_exp} };
        sub emit_go {
            my $self = $_[0];
            ('(*(*' . $self->{obj}->emit_go() . ').(array_er).f_array(Capture' . chr(123) . chr(125) . '))' . '.(index_er).f_index( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . $self->{index_exp}->emit_go() . ' ' . chr(125) . chr(125) . ' )')
        }
    }

;
    {
    package Lookup;
        sub new { shift; bless { @_ }, "Lookup" }
        sub obj { $_[0]->{obj} };
        sub index_exp { $_[0]->{index_exp} };
        sub emit_go {
            my $self = $_[0];
            ('(*(*' . $self->{obj}->emit_go() . ').(hash_er).f_hash(Capture' . chr(123) . chr(125) . '))' . '.(lookup_er).f_lookup( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . $self->{index_exp}->emit_go() . ' ' . chr(125) . chr(125) . ' )')
        }
    }

;
    {
    package Var;
        sub new { shift; bless { @_ }, "Var" }
        sub sigil { $_[0]->{sigil} };
        sub twigil { $_[0]->{twigil} };
        sub namespace { $_[0]->{namespace} };
        sub name { $_[0]->{name} };
        sub emit_go {
            my $self = $_[0];
            ((my  $table) = do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{chr(36)} = 'v_');
    ($Hash_a->{chr(64)} = 'List_');
    ($Hash_a->{chr(37)} = 'Hash_');
    ($Hash_a->{chr(38)} = 'Code_');
    $Hash_a
});
            ((my  $ns) = '');
            if ($self->{namespace}) {
                ($ns = (Main::to_go_namespace($self->{namespace}) . '.'))
            };
            ((($self->{twigil} eq '.')) ? (('(*v_self).(' . $self->{name} . '_er).f_' . $self->{name} . '(Capture' . chr(123) . chr(125) . ')')) : (((($self->{name} eq chr(47))) ? ('v_MATCH') : (($table->{$self->{sigil}} . $ns . $self->{name})))))
        };
        sub plain_name {
            my $self = $_[0];
            if ($self->{namespace}) {
                return scalar (($self->{namespace} . '.' . $self->{name}))
            };
            return scalar ($self->{name})
        }
    }

;
    {
    package Bind;
        sub new { shift; bless { @_ }, "Bind" }
        sub parameters { $_[0]->{parameters} };
        sub arguments { $_[0]->{arguments} };
        sub emit_go {
            my $self = $_[0];
            if (Main::isa($self->{parameters}, 'Lit::Array')) {
                ((my  $a) = $self->{parameters}->array1());
                ((my  $str) = ('func () *Any ' . chr(123) . ' ' . 'List_tmp :' . chr(61) . ' ' . $self->{arguments}->emit_go() . chr(59) . ' '));
                ((my  $i) = 0);
                for my $var ( @{($a)} ) {
                    ((my  $bind) = Bind->new(('parameters' => $var), ('arguments' => Index->new(('obj' => Var->new(('sigil' => chr(64)), ('twigil' => ''), ('namespace' => ''), ('name' => 'tmp'))), ('index_exp' => Val::Int->new(('int' => $i)))))));
                    ($str = ($str . ' ' . $bind->emit_go() . chr(59) . ' '));
                    ($i = ($i + 1))
                };
                return scalar (($str . ' return List_tmp ' . chr(125) . '()'))
            };
            if (Main::isa($self->{parameters}, 'Lit::Hash')) {
                ((my  $a) = $self->{parameters}->hash1());
                ((my  $b) = $self->{arguments}->hash1());
                ((my  $str) = 'do ' . chr(123) . ' ');
                ((my  $i) = 0);
                (my  $arg);
                for my $var ( @{($a)} ) {
                    ($arg = Val::Undef->new());
                    for my $var2 ( @{($b)} ) {
                        if ((($var2->[0])->buf() eq ($var->[0])->buf())) {
                            ($arg = $var2->[1])
                        }
                    };
                    ((my  $bind) = Bind->new(('parameters' => $var->[1]), ('arguments' => $arg)));
                    ($str = ($str . ' ' . $bind->emit_go() . chr(59) . ' '));
                    ($i = ($i + 1))
                };
                return scalar (($str . $self->{parameters}->emit_go() . ' ' . chr(125)))
            };
            if (Main::isa($self->{parameters}, 'Lit::Object')) {
                ((my  $class) = $self->{parameters}->class());
                ((my  $a) = $self->{parameters}->fields());
                ((my  $b) = $self->{arguments});
                ((my  $str) = 'do ' . chr(123) . ' ');
                ((my  $i) = 0);
                (my  $arg);
                for my $var ( @{($a)} ) {
                    ((my  $bind) = Bind->new(('parameters' => $var->[1]), ('arguments' => Call->new(('invocant' => $b), ('method' => ($var->[0])->buf()), ('arguments' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
}), ('hyper' => 0)))));
                    ($str = ($str . ' ' . $bind->emit_go() . chr(59) . ' '));
                    ($i = ($i + 1))
                };
                return scalar (($str . $self->{parameters}->emit_go() . ' ' . chr(125)))
            };
            if (Main::isa($self->{parameters}, 'Call')) {
                return scalar (('func () *Any ' . chr(123) . ' ' . 'var tmp ' . chr(61) . ' ' . Call::emit_go_call($self->{parameters}->invocant(), $self->{parameters}->method()) . chr(59) . ' ' . '*tmp ' . chr(61) . ' *( ' . $self->{arguments}->emit_go() . ' )' . chr(59) . ' ' . 'return tmp' . chr(59) . ' ' . chr(125) . '()'))
            };
            ('*' . $self->{parameters}->emit_go() . ' ' . chr(61) . ' *(' . $self->{arguments}->emit_go() . ')')
        }
    }

;
    {
    package Proto;
        sub new { shift; bless { @_ }, "Proto" }
        sub name { $_[0]->{name} };
        sub emit_go {
            my $self = $_[0];
            Main::to_go_namespace($self->{name})
        }
    }

;
    {
    package Call;
        sub new { shift; bless { @_ }, "Call" }
        sub invocant { $_[0]->{invocant} };
        sub hyper { $_[0]->{hyper} };
        sub method { $_[0]->{method} };
        sub arguments { $_[0]->{arguments} };
        sub emit_go {
            my $self = $_[0];
            ((my  $invocant) = $self->{invocant}->emit_go());
            if (Main::isa(($self->{invocant}), 'Proto')) {
                if (($self->{invocant}->name() eq 'self')) {
                    ($invocant = 'v_self')
                }
                else {
                    ($invocant = ('Proto_' . $invocant))
                }
            };
            ((my  $meth) = $self->{method});
            if (($meth eq 'postcircumfix:<( )>')) {
                if (($self->{hyper})) {
                    ($meth = '')
                }
                else {
                    return scalar (('((*' . $invocant . ').(function_er).f_function( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' ))'))
                }
            };
            if (($self->{hyper})) {
                return scalar (('func (a_ *Any) *Any ' . chr(123) . ' ' . (chr(10)) . '  var out ' . chr(61) . ' a_array()' . chr(59) . ' ' . (chr(10)) . '  var i ' . chr(61) . ' (*(*a_).(array_er).f_array(Capture' . chr(123) . chr(125) . ')).(*Array)' . chr(59) . ' ' . (chr(10)) . '  for pos :' . chr(61) . ' 0' . chr(59) . ' pos <' . chr(61) . ' i.n' . chr(59) . ' pos++ ' . chr(123) . ' ' . (chr(10)) . '    (*out).(push_er).f_push( Capture' . chr(123) . 'p: []*Any' . chr(123) . ' (*i.v[pos]).(' . $meth . '_er).f_' . $meth . '(Capture' . chr(123) . ' p : []*Any' . chr(123) . chr(125) . '  ' . chr(125) . ') ' . chr(125) . chr(125) . ' )' . (chr(10)) . '  ' . chr(125) . ' ' . (chr(10)) . '  return out' . chr(59) . ' ' . (chr(10)) . chr(125) . '(' . $invocant . ')'))
            };
            return scalar (('(*' . $invocant . ').(' . $meth . '_er).f_' . $meth . '( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' )'))
        };
        sub emit_go_call {
            my $invocant = $_[0];
            my $meth_name = $_[1];
            ((my  $invocant1) = $invocant->emit_go());
            if (Main::isa(($invocant), 'Proto')) {
                ($invocant1 = ('Proto_' . $invocant1))
            };
            ((my  $meth) = $meth_name);
            return scalar (('(*' . $invocant1 . ').(' . $meth . '_er).f_' . $meth . '(Capture' . chr(123) . chr(125) . ')'))
        }
    }

;
    {
    package Apply;
        sub new { shift; bless { @_ }, "Apply" }
        sub code { $_[0]->{code} };
        sub arguments { $_[0]->{arguments} };
        sub namespace { $_[0]->{namespace} };
        sub emit_go {
            my $self = $_[0];
            ((my  $code) = $self->{code});
            if (Main::isa($code, 'Str')) {

            }
            else {
                return scalar (('(' . $self->{code}->emit_go() . ')->(' . Main::join(([ map { $_->emit() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            if (($code eq 'self')) {
                return scalar ('v_self')
            };
            if (($code eq 'False')) {
                return scalar ('b_false()')
            };
            if (($code eq 'True')) {
                return scalar ('b_true()')
            };
            if (($code eq 'make')) {
                return scalar (('func () *Any ' . chr(123) . ' ' . 'tmp :' . chr(61) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . chr(59) . ' ' . '*(*v_MATCH).(capture_er).f_capture(Capture' . chr(123) . chr(125) . ') ' . chr(61) . ' *tmp' . chr(59) . ' ' . 'return tmp' . chr(59) . ' ' . chr(125) . '()'))
            };
            if (($code eq 'go')) {
                return scalar (('go func () ' . chr(123) . ' ' . (chr(10)) . '        ' . (Perlito::Go::LexicalBlock->new(('block' => ($self->{arguments}->[0])->block()), ('needs_return' => 0), ('top_level' => 1)))->emit_go() . (chr(10)) . '    ' . chr(125) . '()'))
            };
            if (($code eq 'say')) {
                return scalar (('f_print( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ', toStr(' . chr(34) . chr(92) . 'n' . chr(34) . ') ' . chr(125) . ' ' . chr(125) . ' )'))
            };
            if (($code eq 'print')) {
                return scalar (('f_print( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' )'))
            };
            if (($code eq 'warn')) {
                return scalar (('f_print_stderr( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ', toStr(' . chr(34) . chr(92) . 'n' . chr(34) . ') ' . chr(125) . ' ' . chr(125) . ' )'))
            };
            if (($code eq 'die')) {
                return scalar (('f_die( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' )'))
            };
            if (($code eq 'defined')) {
                return scalar (('f_defined( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' )'))
            };
            if (($code eq 'pop')) {
                return scalar (('f_pop( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' )'))
            };
            if (($code eq 'push')) {
                return scalar (('f_push( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' )'))
            };
            if (($code eq 'shift')) {
                return scalar (('f_shift( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' )'))
            };
            if (($code eq 'index')) {
                return scalar (('f_index( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' )'))
            };
            if (($code eq 'substr')) {
                return scalar (('f_substr( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' )'))
            };
            if (($code eq 'scalar')) {
                return scalar (('f_scalar( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' )'))
            };
            if (($code eq 'Int')) {
                return scalar (('toInt(' . 'toint(' . ($self->{arguments}->[0])->emit_go() . ')' . ')'))
            };
            if (($code eq 'Num')) {
                return scalar (('toNum(' . 'tonum(' . ($self->{arguments}->[0])->emit_go() . ')' . ')'))
            };
            if (($code eq 'exists')) {
                ((my  $arg) = $self->{arguments}->[0]);
                if (Main::isa($arg, 'Lookup')) {
                    return scalar (('(*' . ($arg->obj())->emit_go() . ')' . '.(exists_er).f_exists(Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . ($arg->index_exp())->emit_go() . ' ' . chr(125) . ' ' . chr(125) . ' )'))
                }
            };
            if (($code eq 'prefix:<' . chr(126) . '>')) {
                return scalar (Call::emit_go_call($self->{arguments}->[0], 'Str'))
            };
            if (($code eq 'prefix:<' . chr(33) . '>')) {
                return scalar (('toBool(' . chr(33) . 'tobool(' . ($self->{arguments}->[0])->emit_go() . '))'))
            };
            if (($code eq 'prefix:<' . chr(63) . '>')) {
                return scalar (Call::emit_go_call($self->{arguments}->[0], 'Bool'))
            };
            if (($code eq 'prefix:<' . chr(36) . '>')) {
                return scalar (('f_scalar( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' )'))
            };
            if (($code eq 'prefix:<' . chr(64) . '>')) {
                return scalar (Call::emit_go_call($self->{arguments}->[0], 'array'))
            };
            if (($code eq 'prefix:<' . chr(37) . '>')) {
                return scalar (Call::emit_go_call($self->{arguments}->[0], 'hash'))
            };
            if (($code eq 'infix:<' . chr(126) . '>')) {
                return scalar (('toStr( ' . 'tostr(' . ($self->{arguments}->[0])->emit_go() . ') + ' . 'tostr(' . ($self->{arguments}->[1])->emit_go() . ') ' . ')'))
            };
            if (($code eq 'infix:<+>')) {
                return scalar (('f_add( ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            if (($code eq 'infix:<->')) {
                return scalar (('f_sub( ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            if (($code eq 'infix:<*>')) {
                return scalar (('f_mul( ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            if (($code eq 'infix:<' . chr(47) . '>')) {
                return scalar (('f_div( ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            if (($code eq 'infix:<>>')) {
                return scalar (('f_greater( ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            if (($code eq 'infix:<<>')) {
                return scalar (('f_smaller( ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ')'))
            };
            if (($code eq 'infix:<>' . chr(61) . '>')) {
                return scalar (('toBool( ' . 'toint(' . ($self->{arguments}->[0])->emit_go() . ') >' . chr(61) . ' ' . 'toint(' . ($self->{arguments}->[1])->emit_go() . ') ' . ')'))
            };
            if (($code eq 'infix:<<' . chr(61) . '>')) {
                return scalar (('toBool( ' . 'toint(' . ($self->{arguments}->[0])->emit_go() . ') <' . chr(61) . ' ' . 'toint(' . ($self->{arguments}->[1])->emit_go() . ') ' . ')'))
            };
            if (($code eq 'infix:<' . chr(38) . chr(38) . '>')) {
                return scalar (('f_and( ' . 'func () *Any ' . chr(123) . ' return ' . ($self->{arguments}->[0])->emit_go() . ' ' . chr(125) . ', ' . 'func () *Any ' . chr(123) . ' return ' . ($self->{arguments}->[1])->emit_go() . ' ' . chr(125) . ' ' . ')'))
            };
            if (($code eq 'infix:<' . chr(124) . chr(124) . '>')) {
                return scalar (('f_or( ' . 'func () *Any ' . chr(123) . ' return ' . ($self->{arguments}->[0])->emit_go() . ' ' . chr(125) . ', ' . 'func () *Any ' . chr(123) . ' return ' . ($self->{arguments}->[1])->emit_go() . ' ' . chr(125) . ' ' . ')'))
            };
            if (($code eq 'infix:<eq>')) {
                return scalar (('toBool(' . 'tostr(' . ($self->{arguments}->[0])->emit_go() . ') ' . chr(61) . chr(61) . ' ' . 'tostr(' . ($self->{arguments}->[1])->emit_go() . ')' . ')'))
            };
            if (($code eq 'infix:<ne>')) {
                return scalar (('toBool(' . 'tostr(' . ($self->{arguments}->[0])->emit_go() . ') ' . chr(33) . chr(61) . ' ' . 'tostr(' . ($self->{arguments}->[1])->emit_go() . ')' . ')'))
            };
            if (($code eq 'infix:<' . chr(61) . chr(61) . '>')) {
                return scalar (('toBool(' . 'toint(' . ($self->{arguments}->[0])->emit_go() . ') ' . chr(61) . chr(61) . ' ' . 'toint(' . ($self->{arguments}->[1])->emit_go() . ') ' . ')'))
            };
            if (($code eq 'infix:<' . chr(33) . chr(61) . '>')) {
                return scalar (('toBool(' . 'toint(' . ($self->{arguments}->[0])->emit_go() . ') ' . chr(33) . chr(61) . ' ' . 'toint(' . ($self->{arguments}->[1])->emit_go() . ') ' . ')'))
            };
            if (($code eq 'ternary:<' . chr(63) . chr(63) . ' ' . chr(33) . chr(33) . '>')) {
                return scalar (('func () *Any ' . chr(123) . ' ' . 'if tobool( ' . Call::emit_go_call($self->{arguments}->[0], 'Bool') . ' ) ' . chr(123) . ' return ' . ($self->{arguments}->[1])->emit_go() . ' ' . chr(125) . chr(59) . ' ' . 'return ' . ($self->{arguments}->[2])->emit_go() . ' ' . chr(125) . '()'))
            };
            ($code = ('f_' . $self->{code}));
            if ($self->{namespace}) {
                ($code = ('Namespace_' . Main::to_go_namespace($self->{namespace}) . '.' . $code))
            }
            else {
                ($code = ('this_namespace.' . $code))
            };
            ($code . '( Capture' . chr(123) . ' p : []*Any' . chr(123) . ' ' . Main::join(([ map { $_->emit_go() } @{( $self->{arguments} )} ]), ', ') . ' ' . chr(125) . ' ' . chr(125) . ' )')
        }
    }

;
    {
    package Return;
        sub new { shift; bless { @_ }, "Return" }
        sub result { $_[0]->{result} };
        sub emit_go {
            my $self = $_[0];
            if (Main::isa(($self->{result}), 'Bind')) {
                ((my  $tmp) = ($self->{result})->parameters());
                return scalar (('(func () ' . chr(123) . ' ' . ($self->{result})->emit_go() . chr(59) . ' ' . 'p <- ' . $tmp->emit_go() . chr(59) . ' ' . 'runtime.Goexit()' . chr(59) . ' ' . chr(125) . '())'))
            };
            return scalar (('(func () ' . chr(123) . ' ' . 'var tmp *Any ' . chr(61) . ' ' . ($self->{result})->emit_go() . chr(59) . ' ' . 'p <- tmp' . chr(59) . ' ' . 'runtime.Goexit()' . chr(59) . ' ' . chr(125) . '())'))
        };
        sub emit_go_simple {
            my $self = $_[0];
            if (Main::isa(($self->{result}), 'Bind')) {
                ((my  $tmp) = ($self->{result})->parameters());
                return scalar (('return (func () *Any ' . chr(123) . ' ' . ($self->{result})->emit_go() . chr(59) . ' ' . 'return ' . $tmp->emit_go() . chr(59) . ' ' . chr(125) . '())'))
            };
            return scalar (('return( ' . $self->{result}->emit_go() . ')'))
        }
    }

;
    {
    package If;
        sub new { shift; bless { @_ }, "If" }
        sub cond { $_[0]->{cond} };
        sub body { $_[0]->{body} };
        sub otherwise { $_[0]->{otherwise} };
        sub emit_go {
            my $self = $_[0];
            ((my  $cond) = $self->{cond});
            if ((Main::isa($cond, 'Apply') && ($cond->code() eq 'prefix:<' . chr(33) . '>'))) {
                ((my  $if) = If->new(('cond' => ($cond->arguments())->[0]), ('body' => $self->{otherwise}), ('otherwise' => $self->{body})));
                return scalar ($if->emit_go())
            };
            if ((Main::isa($cond, 'Var') && ($cond->sigil() eq chr(64)))) {
                ($cond = Apply->new(('code' => 'prefix:<' . chr(64) . '>'), ('arguments' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $cond );
    $List_a
})))
            };
            ((my  $s) = ('if tobool( ' . Call::emit_go_call($cond, 'Bool') . ' ) ' . chr(123) . ' ' . (Perlito::Go::LexicalBlock->new(('block' => $self->{body}), ('needs_return' => 0)))->emit_go() . ' ' . chr(125)));
            if (!(($self->{otherwise}))) {
                return scalar ($s)
            };
            return scalar (($s . ' else ' . chr(123) . ' ' . (Perlito::Go::LexicalBlock->new(('block' => $self->{otherwise}), ('needs_return' => 0)))->emit_go() . ' ' . chr(125)))
        }
    }

;
    {
    package For;
        sub new { shift; bless { @_ }, "For" }
        sub cond { $_[0]->{cond} };
        sub body { $_[0]->{body} };
        sub topic { $_[0]->{topic} };
        sub emit_go {
            my $self = $_[0];
            ('func (a_ *Any) ' . chr(123) . ' ' . (chr(10)) . '  var i ' . chr(61) . ' (*(*a_).(array_er).f_array(Capture' . chr(123) . chr(125) . ')).(*Array)' . chr(59) . ' ' . (chr(10)) . '  for pos :' . chr(61) . ' 0' . chr(59) . ' pos <' . chr(61) . ' i.n' . chr(59) . ' pos++ ' . chr(123) . ' ' . (chr(10)) . '    func (' . $self->{topic}->emit_go() . ' *Any) ' . chr(123) . ' ' . (chr(10)) . '      ' . (Perlito::Go::LexicalBlock->new(('block' => $self->{body}), ('needs_return' => 0)))->emit_go() . (chr(10)) . '    ' . chr(125) . '(i.v[pos]) ' . (chr(10)) . '  ' . chr(125) . ' ' . (chr(10)) . chr(125) . '(' . $self->{cond}->emit_go() . ')')
        }
    }

;
    {
    package When;
        sub new { shift; bless { @_ }, "When" }
        sub parameters { $_[0]->{parameters} };
        sub body { $_[0]->{body} };
        sub emit_go {
            my $self = $_[0];
            die(('TODO - When'))
        }
    }

;
    {
    package While;
        sub new { shift; bless { @_ }, "While" }
        sub init { $_[0]->{init} };
        sub cond { $_[0]->{cond} };
        sub continue { $_[0]->{continue} };
        sub body { $_[0]->{body} };
        sub emit_go {
            my $self = $_[0];
            ((my  $cond) = $self->{cond});
            if ((Main::isa($cond, 'Var') && ($cond->sigil() eq chr(64)))) {
                ($cond = Apply->new(('code' => 'prefix:<' . chr(64) . '>'), ('arguments' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $cond );
    $List_a
})))
            };
            return scalar (('for ' . (($self->{init} ? ($self->{init}->emit_go() . chr(59) . ' ') : chr(59))) . 'tobool( ' . Call::emit_go_call($cond, 'Bool') . ' )' . chr(59) . ' ' . (($self->{continue} ? ($self->{continue}->emit_go() . ' ') : '')) . chr(123) . ' ' . (Perlito::Go::LexicalBlock->new(('block' => $self->{body}), ('needs_return' => 0)))->emit_go() . ' ' . chr(125)))
        }
    }

;
    {
    package Decl;
        sub new { shift; bless { @_ }, "Decl" }
        sub decl { $_[0]->{decl} };
        sub type { $_[0]->{type} };
        sub var { $_[0]->{var} };
        sub emit_go {
            my $self = $_[0];
            $self->{var}->emit_go()
        };
        sub emit_go_init {
            my $self = $_[0];
            if (($self->{decl} eq 'my')) {
                ((my  $str) = '');
                ($str = ($str . 'var ' . ($self->{var})->emit_go() . ' *Any' . chr(59) . (chr(10))));
                ($str = ($str . ($self->{var})->emit_go() . ' ' . chr(61) . ' ' . ($self->{var})->emit_go() . chr(59) . (chr(10))));
                if ((($self->{var})->sigil() eq chr(37))) {
                    ($str = ($str . ($self->{var})->emit_go() . ' ' . chr(61) . ' h_hash()' . chr(59) . (chr(10))))
                }
                else {
                    if ((($self->{var})->sigil() eq chr(64))) {
                        ($str = ($str . ($self->{var})->emit_go() . ' ' . chr(61) . ' a_array()' . chr(59) . (chr(10))))
                    }
                    else {
                        ($str = ($str . ($self->{var})->emit_go() . ' ' . chr(61) . ' u_undef()' . chr(59) . (chr(10))))
                    }
                };
                return scalar ($str)
            }
            else {
                die(('not implemented: Decl ' . chr(39) . $self->{decl} . (chr(39))))
            }
        }
    }

;
    {
    package Sig;
        sub new { shift; bless { @_ }, "Sig" }
        sub invocant { $_[0]->{invocant} };
        sub positional { $_[0]->{positional} };
        sub named { $_[0]->{named} };
        sub emit_go {
            my $self = $_[0];
            ' print ' . chr(39) . 'Signature - TODO' . chr(39) . chr(59) . ' die ' . chr(39) . 'Signature - TODO' . chr(39) . chr(59) . ' '
        };
        sub emit_go_bind {
            my $self = $_[0];
            ((my  $str) = '');
            ((my  $i) = 0);
            for my $decl ( @{(($self->{positional}))} ) {
                ($str = ($str . ('  var ') . $decl->emit_go() . (' *Any' . chr(59) . chr(10)) . ('  if len(v.p) > ') . $i . (' ' . chr(123) . chr(10)) . ('    ') . $decl->emit_go() . (' ' . chr(61) . ' v.p[') . $i . (']' . chr(59) . chr(10)) . ('  ' . chr(125) . chr(10))));
                ($str = ($str . $decl->emit_go() . ' ' . chr(61) . ' ' . $decl->emit_go() . chr(59) . ' '));
                ($i = ($i + 1))
            };
            return scalar ($str)
        }
    }

;
    {
    package Method;
        sub new { shift; bless { @_ }, "Method" }
        sub name { $_[0]->{name} };
        sub sig { $_[0]->{sig} };
        sub block { $_[0]->{block} };
        sub emit_go {
            my $self = $_[0];
            ((my  $invocant) = ($self->{sig})->invocant());
            ('func ' . $self->{name} . '(v Capture) *Any ' . chr(123) . ' ' . '    ' . ($self->{sig})->emit_go_bind() . (chr(10)) . '    p :' . chr(61) . ' make(chan *Any)' . chr(59) . ' go func () ' . chr(123) . ' ' . (chr(10)) . '        ' . (Perlito::Go::LexicalBlock->new(('block' => $self->{block}), ('needs_return' => 1), ('top_level' => 1)))->emit_go() . chr(59) . ' p <- nil ' . chr(125) . '()' . chr(59) . ' ' . (chr(10)) . '    return <-p' . chr(59) . ' ' . (chr(10)) . ' ' . chr(125))
        }
    }

;
    {
    package Sub;
        sub new { shift; bless { @_ }, "Sub" }
        sub name { $_[0]->{name} };
        sub sig { $_[0]->{sig} };
        sub block { $_[0]->{block} };
        sub emit_go {
            my $self = $_[0];
            if (($self->{name} eq '')) {
                return scalar (('toFunction( func(v Capture) *Any ' . chr(123) . ' ' . '    ' . ($self->{sig})->emit_go_bind() . (chr(10)) . '    p :' . chr(61) . ' make(chan *Any)' . chr(59) . ' go func () ' . chr(123) . ' ' . (chr(10)) . '        ' . (Perlito::Go::LexicalBlock->new(('block' => $self->{block}), ('needs_return' => 1), ('top_level' => 1)))->emit_go() . chr(59) . ' p <- nil ' . chr(125) . '()' . chr(59) . ' ' . (chr(10)) . '    return <-p' . chr(59) . ' ' . (chr(10)) . chr(125) . ' ' . ')'))
            };
            ('func ' . $self->{name} . '(v Capture) *Any ' . chr(123) . ' ' . '    ' . ($self->{sig})->emit_go_bind() . (chr(10)) . '    p :' . chr(61) . ' make(chan *Any)' . chr(59) . ' go func () ' . chr(123) . ' ' . (chr(10)) . '        ' . (Perlito::Go::LexicalBlock->new(('block' => $self->{block}), ('needs_return' => 1), ('top_level' => 1)))->emit_go() . chr(59) . ' p <- nil ' . chr(125) . '()' . chr(59) . ' ' . (chr(10)) . '    return <-p' . chr(59) . ' ' . (chr(10)) . ' ' . chr(125))
        }
    }

;
    {
    package Do;
        sub new { shift; bless { @_ }, "Do" }
        sub block { $_[0]->{block} };
        sub emit_go {
            my $self = $_[0];
            ('(func () *Any ' . chr(123) . ' ' . (Perlito::Go::LexicalBlock->new(('block' => $self->{block}), ('needs_return' => 1)))->emit_go() . chr(59) . ' return u_undef() ' . chr(125) . ')()')
        }
    }

;
    {
    package Use;
        sub new { shift; bless { @_ }, "Use" }
        sub mod { $_[0]->{mod} };
        sub emit_go {
            my $self = $_[0];
            (chr(47) . chr(47) . ' use ' . $self->{mod} . (chr(10)))
        }
    }


}

1;
