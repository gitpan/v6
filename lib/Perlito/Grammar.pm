# Do not edit this file - Generated by Perlito 6.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito::Perl5::Runtime;
our $MATCH = Perlito::Match->new();
{
package GLOBAL;
sub new { shift; bless { @_ }, "GLOBAL" }

# use v6 
;
{
package Perlito::Grammar;
sub new { shift; bless { @_ }, "Perlito::Grammar" }
use Perlito::Expression;
use Perlito::Grammar::Regex;
use Perlito::Grammar::Control;
sub ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((do { do { (my  $pos1 = $MATCH->to()); ((do { do { (((do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $m2 = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } }) } })); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }) && (do { do { (my  $m2 = $grammar->word($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('_' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) } }) && (do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); for ( ; Main::bool(((do { do { (my  $pos1 = $MATCH->to()); (((do { do { ((do { do { (my  $m2 = $grammar->word($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('_' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((do { do { (my  $m2 = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } })) } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) } }))); $MATCH };
sub full_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((do { do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); for ( ; Main::bool(((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((((Main::bool((('::' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) } }))); $MATCH };
sub namespace_before_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((((do { do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('::' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0))) } }) } })); (($tmp)->{bool} = ($MATCH ? 1 : 0)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } })) && (do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); for ( ; Main::bool(((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((((Main::bool((('::' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('::' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0))) } }) } })); (($tmp)->{bool} = ($MATCH ? 1 : 0)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }))) } }) } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) } }))); $MATCH };
sub optional_namespace_before_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((((do { do { (my  $m2 = $grammar->namespace_before_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'namespace_before_ident'} = $m2); 1 } else { 0 } } }) && ((Main::bool((('::' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (("" . $MATCH->{'namespace_before_ident'}))) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((1 && (((do { do { ($MATCH->{capture} = ('')) } }) || 1)))) } })) } }))); $MATCH };
sub pod_begin { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((((do { do { (my  $m2 = $grammar->is_newline($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && ((Main::bool((('=end' eq substr($str, $MATCH->to(), 4)))) ? ((1 + ((($MATCH)->{to} = (4 + $MATCH->to()))))) : 0))) && (do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); for ( ; Main::bool(((do { do { (my  $m2 = $grammar->not_newline($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((((Main::bool((('' ne substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); for ( ; Main::bool(((do { do { (my  $m2 = $grammar->not_newline($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } })) && (do { do { (my  $m2 = $grammar->pod_begin($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } })) } }))); $MATCH };
sub ws { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); (my  $count = 0); for ( ; Main::bool(((do { do { (my  $pos1 = $MATCH->to()); (((do { do { ((((Main::bool((('#' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); for ( ; Main::bool(((do { do { (my  $m2 = $grammar->not_newline($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = $grammar->is_newline($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (do { do { (my  $pos1 = $MATCH->to()); (((do { do { ((((Main::bool((('=begin' eq substr($str, $MATCH->to(), 6)))) ? ((1 + ((($MATCH)->{to} = (6 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->pod_begin($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((Main::bool((('=for' eq substr($str, $MATCH->to(), 4)))) ? ((1 + ((($MATCH)->{to} = (4 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->pod_begin($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } })) || (do { do { (($MATCH)->{to} = $pos1); (1) } })) } }))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((do { do { (my  $m2 = $grammar->space($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } })) } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()); ($count = ($count + 1)) }; (($MATCH)->{to} = $last_pos); ($count > 0) } })) } }) } }))); $MATCH };
sub opt_ws { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) } }) } }))); $MATCH };
sub opt_ws2 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) } }) } }))); $MATCH };
sub opt_ws3 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) } }) } }))); $MATCH };
sub grammar { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((((((((do { do { (my  $m2 = $grammar->full_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'full_ident'} = $m2); 1 } else { 0 } } }) && (do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) && ((Main::bool((('{' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) && (do { do { (my  $m2 = $grammar->exp_stmts($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'exp_stmts'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = $grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) && ((Main::bool((('}' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (CompUnit->new(('name' => ${$MATCH->{'full_ident'}}), ('body' => ${$MATCH->{'exp_stmts'}})))) } }) || 1)))) } }) } }))); $MATCH };
sub declarator { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (((do { do { (((Main::bool((('my' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('state' eq substr($str, $MATCH->to(), 5)))) ? ((1 + ((($MATCH)->{to} = (5 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('has' eq substr($str, $MATCH->to(), 3)))) ? ((1 + ((($MATCH)->{to} = (3 + $MATCH->to()))))) : 0))) } })) } }))); $MATCH };
sub exp_stmts2 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((do { do { (my  $m2 = $grammar->exp_stmts($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'exp_stmts'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'exp_stmts'}})) } }) || 1)))) } }) } }))); $MATCH };
sub exp { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((do { do { (my  $m2 = Perlito::Expression->exp_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.exp_parse'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'Perlito::Expression.exp_parse'}})) } }) || 1)))) } }) } }))); $MATCH };
sub exp2 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((do { do { (my  $m2 = Perlito::Expression->exp_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.exp_parse'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'Perlito::Expression.exp_parse'}})) } }) || 1)))) } }) } }))); $MATCH };
sub opt_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { (((do { do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'ident'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'ident'}})) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((1 && (((do { do { ($MATCH->{capture} = ('postcircumfix:<( )>')) } }) || 1)))) } })) } }))); $MATCH };
sub opt_type { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((((do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { ((Main::bool((('::' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0)) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } }) && (do { do { (my  $m2 = $grammar->full_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'full_ident'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'full_ident'}})) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((1 && (((do { do { ($MATCH->{capture} = ('')) } }) || 1)))) } })) } }))); $MATCH };
sub var_sigil { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); ((((do { do { (((Main::bool((('$' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('%' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('@' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('&' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) } }))); $MATCH };
sub var_twigil { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $pos1 = $MATCH->to()); ((((do { do { (((Main::bool((('.' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('!' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('^' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('*' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) } }) } }))); $MATCH };
sub var_name { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (((do { do { ((do { do { (my  $m2 = $grammar->full_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'full_ident'} = $m2); 1 } else { 0 } } })) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('/' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((do { do { (my  $m2 = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'digit'} = $m2); 1 } else { 0 } } })) } })) } }))); $MATCH };
sub var_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((((((do { do { (my  $m2 = $grammar->var_sigil($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'var_sigil'} = $m2); 1 } else { 0 } } }) && (do { do { (my  $m2 = $grammar->var_twigil($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'var_twigil'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->optional_namespace_before_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'optional_namespace_before_ident'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->var_name($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'var_name'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (Var->new(('sigil' => ("" . $MATCH->{'var_sigil'})), ('twigil' => ("" . $MATCH->{'var_twigil'})), ('namespace' => ${$MATCH->{'optional_namespace_before_ident'}}), ('name' => ("" . $MATCH->{'var_name'}))))) } }) || 1)))) } }) } }))); $MATCH };
sub exponent { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((((do { do { (my  $pos1 = $MATCH->to()); ((do { do { (((Main::bool((('e' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('E' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) } }) && (do { do { (my  $pos1 = $MATCH->to()); (((do { do { (((Main::bool((('+' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('-' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (1) } })) } })) && (do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); (my  $count = 0); for ( ; Main::bool(((do { do { (my  $m2 = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()); ($count = ($count + 1)) }; (($MATCH)->{to} = $last_pos); ($count > 0) } }))) } }) } }))); $MATCH };
sub val_num { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((do { do { (my  $pos1 = $MATCH->to()); ((do { do { (((((Main::bool((('.' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); (my  $count = 0); for ( ; Main::bool(((do { do { (my  $m2 = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()); ($count = ($count + 1)) }; (($MATCH)->{to} = $last_pos); ($count > 0) } })) && (do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = $grammar->exponent($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); (my  $count = 0); for ( ; Main::bool(((do { do { (my  $m2 = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()); ($count = ($count + 1)) }; (($MATCH)->{to} = $last_pos); ($count > 0) } }) && (do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((do { do { (my  $m2 = $grammar->exponent($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } }) || (do { do { (($MATCH)->{to} = $pos1); (((((Main::bool((('.' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); (my  $count = 0); for ( ; Main::bool(((do { do { (my  $m2 = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()); ($count = ($count + 1)) }; (($MATCH)->{to} = $last_pos); ($count > 0) } })) && (do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = $grammar->exponent($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } }))) } })) } }))) } })) } }) && (((do { do { ($MATCH->{capture} = (Val::Num->new(('num' => ("" . $MATCH))))) } }) || 1)))) } }) } }))); $MATCH };
sub char_any { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('' ne substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) } }))); $MATCH };
sub char_any_single_quote { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((((do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('\'' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) } })); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }) && ((Main::bool((('' ne substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); for ( ; Main::bool(((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { (((Main::bool((('\'' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('\\' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) } })) } }) } })); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }) && ((Main::bool((('' ne substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)))) } }) } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) } }))); $MATCH };
sub single_quoted_unescape { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (((((do { do { ((((((Main::bool((('\\' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && ((Main::bool((('\\' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (do { do { (my  $m2 = $grammar->single_quoted_unescape($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'single_quoted_unescape'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = ('\\' . $MATCH->{'single_quoted_unescape'})) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('\\' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && ((Main::bool((('\'' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (do { do { (my  $m2 = $grammar->single_quoted_unescape($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'single_quoted_unescape'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = ('\'' . $MATCH->{'single_quoted_unescape'})) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((((Main::bool((('\\' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->single_quoted_unescape($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'single_quoted_unescape'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = ('\\' . $MATCH->{'single_quoted_unescape'})) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { (my  $m2 = $grammar->char_any_single_quote($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'char_any_single_quote'} = $m2); 1 } else { 0 } } }) && (do { do { (my  $m2 = $grammar->single_quoted_unescape($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'single_quoted_unescape'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = ($MATCH->{'char_any_single_quote'} . $MATCH->{'single_quoted_unescape'})) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (1) } })) } }))); $MATCH };
sub char_any_double_quote { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((((do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $pos1 = $MATCH->to()); (((((do { do { (((Main::bool((('"' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('$' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('@' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('%' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('{' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) } })) } }) } })); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }) && ((Main::bool((('' ne substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); for ( ; Main::bool(((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $pos1 = $MATCH->to()); ((((((do { do { (((Main::bool((('"' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('$' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('@' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('%' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('{' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((Main::bool((('\\' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } })) } })) } }) } })); (($tmp)->{bool} = ($MATCH ? 0 : 1)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }) && ((Main::bool((('' ne substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)))) } }) } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) } }))); $MATCH };
sub double_quoted_unescape { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (((do { do { (((((Main::bool((('\\' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && ((Main::bool((('n' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = ('
')) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((((Main::bool((('\\' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->char_any($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'char_any'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (("" . $MATCH->{'char_any'}))) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = $grammar->char_any_double_quote($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'char_any_double_quote'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (("" . $MATCH->{'char_any_double_quote'}))) } }) || 1)))) } })) } }))); $MATCH };
sub double_quoted_buf { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (((((do { do { (((do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('$' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) } })); (($tmp)->{bool} = ($MATCH ? 1 : 0)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }) && (do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((((do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { (((((Main::bool((('$' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->var_twigil($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) } })); (($tmp)->{bool} = ($MATCH ? 1 : 0)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }) && (do { do { (my  $m2 = Perlito::Expression->operator($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.operator'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = ((${$MATCH->{'Perlito::Expression.operator'}})->[1])) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = $grammar->char_any($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'char_any'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (Val::Buf->new(('buf' => ("" . $MATCH->{'char_any'}))))) } }) || 1)))) } })) } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('@' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) } })); (($tmp)->{bool} = ($MATCH ? 1 : 0)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }) && (do { do { (my  $pos1 = $MATCH->to()); ((do { do { (((((do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { (((((Main::bool((('@' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->var_twigil($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) } })); (($tmp)->{bool} = ($MATCH ? 1 : 0)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }) && (do { do { (my  $m2 = Perlito::Expression->operator($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.operator'} = $m2); 1 } else { 0 } } })) && ((Main::bool((('[]' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = ((${$MATCH->{'Perlito::Expression.operator'}})->[1])) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = $grammar->char_any($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'char_any'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (Val::Buf->new(('buf' => ("" . $MATCH->{'char_any'}))))) } }) || 1)))) } })) } }))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { (((Main::bool((('%' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) } })); (($tmp)->{bool} = ($MATCH ? 1 : 0)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }) && (do { do { (my  $pos1 = $MATCH->to()); ((do { do { (((((do { do { (my  $tmp = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { (my  $pos1 = $MATCH->to()); (do { do { (((((Main::bool((('%' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->var_twigil($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) } })); (($tmp)->{bool} = ($MATCH ? 1 : 0)); ($MATCH = $tmp); ($MATCH ? 1 : 0) } }) && (do { do { (my  $m2 = Perlito::Expression->operator($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.operator'} = $m2); 1 } else { 0 } } })) && ((Main::bool((('{}' eq substr($str, $MATCH->to(), 2)))) ? ((1 + ((($MATCH)->{to} = (2 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = ((${$MATCH->{'Perlito::Expression.operator'}})->[1])) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = $grammar->char_any($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'char_any'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (Val::Buf->new(('buf' => ("" . $MATCH->{'char_any'}))))) } }) || 1)))) } })) } }))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('{' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->exp_stmts($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'exp_stmts'} = $m2); 1 } else { 0 } } })) && ((Main::bool((('}' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (Do->new(('block' => Lit::Block->new(('stmts' => ${$MATCH->{'exp_stmts'}})))))) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { (my  $m2 = $grammar->double_quoted_unescape($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'double_quoted_unescape'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (Val::Buf->new(('buf' => ${$MATCH->{'double_quoted_unescape'}})))) } }) || 1)))) } })) } }))); $MATCH };
sub val_buf { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((((((Main::bool((('"' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); for ( ; Main::bool(((do { do { (my  $m2 = $grammar->double_quoted_buf($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); if (Main::bool(exists($MATCH->{'double_quoted_buf'}))) { push( @{($MATCH->{'double_quoted_buf'})}, $m2 ) } else { ($MATCH->{'double_quoted_buf'} = [$m2]) }; 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } })) && ((Main::bool((('"' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { (my  $args = $MATCH->{'double_quoted_buf'}); if (Main::bool(($args ? 0 : 1))) { ($MATCH->{capture} = (Val::Buf->new(('buf' => '')))) } else { ($MATCH->{capture} = (Apply->new(('namespace' => ''), ('code' => 'list:<~>'), ('arguments' => [ map { $_->capture() } @{ ($MATCH->{'double_quoted_buf'}) } ])))) } } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((((Main::bool((('\'' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->single_quoted_unescape($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'single_quoted_unescape'} = $m2); 1 } else { 0 } } })) && ((Main::bool((('\'' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (Val::Buf->new(('buf' => ${$MATCH->{'single_quoted_unescape'}})))) } }) || 1)))) } })) } }))); $MATCH };
sub val_int { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((do { do { (my  $last_match_null = 0); (my  $last_pos = $MATCH->to()); (my  $count = 0); for ( ; Main::bool(((do { do { (my  $m2 = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()); ($count = ($count + 1)) }; (($MATCH)->{to} = $last_pos); ($count > 0) } }) && (((do { do { ($MATCH->{capture} = (Val::Int->new(('int' => ("" . $MATCH))))) } }) || 1)))) } }) } }))); $MATCH };
sub exp_stmts { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { (((do { do { (my  $m2 = Perlito::Expression->statement_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.statement_parse'} = $m2); 1 } else { 0 } } }) && (do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((((((((do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (do { do { (my  $pos1 = $MATCH->to()); ((do { do { (((Main::bool(((';' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); (1) } })) } })) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->exp_stmts($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'exp_stmts'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((((Main::bool(((';' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); (1) } })) } })) && (((do { do { ($MATCH->{capture} = ([${$MATCH->{'Perlito::Expression.statement_parse'}}, @{((${$MATCH->{'exp_stmts'}}) || []) || []}])) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((((Main::bool(((';' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0)) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); (1) } })) } })) && (((do { do { ($MATCH->{capture} = ([${$MATCH->{'Perlito::Expression.statement_parse'}}])) } }) || 1)))) } })) } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { ($MATCH->{capture} = ([])) } }) || 1))) } })) } }))); $MATCH };
sub opt_name { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { ((do { do { (my  $last_pos = $MATCH->to()); if (Main::bool(((do { do { (do { do { (my  $m2 = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); if (Main::bool(exists($MATCH->{'ident'}))) { push( @{($MATCH->{'ident'})}, $m2 ) } else { ($MATCH->{'ident'} = [$m2]) }; 1 } else { 0 } } }) } }) ? 0 : 1))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) } }) } }))); $MATCH };
sub var_invocant { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((((do { do { (my  $m2 = $grammar->var_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'var_ident'} = $m2); 1 } else { 0 } } }) && ((Main::bool(((':' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'var_ident'}})) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { ($MATCH->{capture} = (Var->new(('sigil' => '$'), ('twigil' => ''), ('name' => 'self')))) } }) || 1))) } })) } }))); $MATCH };
sub args_sig { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((((do { do { (my  $m2 = $grammar->var_invocant($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'var_invocant'} = $m2); 1 } else { 0 } } }) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = Perlito::Expression->list_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.list_parse'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (Sig->new(('invocant' => ${$MATCH->{'var_invocant'}}), ('positional' => Perlito::Expression::expand_list((${$MATCH->{'Perlito::Expression.list_parse'}})->{'exp'})), ('named' => {  })))) } }) || 1)))) } }) } }))); $MATCH };
sub method_sig { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); ((do { do { ((((((((do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && ((Main::bool((('(' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->args_sig($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'args_sig'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && ((Main::bool(((')' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'args_sig'}})) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { ($MATCH->{capture} = (Sig->new(('invocant' => Var->new(('sigil' => '$'), ('twigil' => ''), ('name' => 'self'))), ('positional' => []), ('named' => {  })))) } }) || 1))) } })) } }))); $MATCH };
sub method_def { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((((((((((do { do { (my  $m2 = $grammar->opt_name($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'opt_name'} = $m2); 1 } else { 0 } } }) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->method_sig($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'method_sig'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && ((Main::bool((('{' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->exp_stmts($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'exp_stmts'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $pos1 = $MATCH->to()); ((do { do { (((Main::bool((('}' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { die('Syntax Error in method \'.', ${$MATCH->{'name'}}, '\' near pos=', $MATCH->to()) } }) || 1))) } })) } })) && (((do { do { ($MATCH->{capture} = (Method->new(('name' => ${$MATCH->{'opt_name'}}), ('sig' => ${$MATCH->{'method_sig'}}), ('block' => ${$MATCH->{'exp_stmts'}})))) } }) || 1)))) } }) } }))); $MATCH };
sub sub_def { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((((((((((do { do { (my  $m2 = $grammar->opt_name($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'opt_name'} = $m2); 1 } else { 0 } } }) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->method_sig($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'method_sig'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && ((Main::bool((('{' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->exp_stmts($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'exp_stmts'} = $m2); 1 } else { 0 } } })) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { (my  $pos1 = $MATCH->to()); ((do { do { (((Main::bool((('}' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { die('Syntax Error in sub \'', ${$MATCH->{'name'}}, '\'') } }) || 1))) } })) } })) && (((do { do { ($MATCH->{capture} = (Sub->new(('name' => ${$MATCH->{'opt_name'}}), ('sig' => ${$MATCH->{'method_sig'}}), ('block' => ${$MATCH->{'exp_stmts'}})))) } }) || 1)))) } }) } }))); $MATCH };
sub token { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my  $MATCH; ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { (my  $pos1 = $MATCH->to()); (do { do { (((((((do { do { (my  $m2 = $grammar->opt_name($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'opt_name'} = $m2); 1 } else { 0 } } }) && (do { do { (my  $m2 = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && ((Main::bool((('{' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (do { do { (my  $m2 = Perlito::Grammar::Regex->rule($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Grammar::Regex.rule'} = $m2); 1 } else { 0 } } })) && ((Main::bool((('}' eq substr($str, $MATCH->to(), 1)))) ? ((1 + ((($MATCH)->{to} = (1 + $MATCH->to()))))) : 0))) && (((do { do { (my  $source = $MATCH->{'opt_name'} . ' ( $grammar: $str, $pos ) { ' . 'my $MATCH; $MATCH = Perlito::Match.new( str => $str, from => $pos, to => $pos, bool => 1 ); ' . '$MATCH.bool = ( ' . (${$MATCH->{'Perlito::Grammar::Regex.rule'}})->emit() . '); ' . '$MATCH }'); (my  $ast = Perlito::Grammar->method_def($source, 0)); ($MATCH->{capture} = (${$ast})) } }) || 1)))) } }) } }))); $MATCH }
}


}

1;
