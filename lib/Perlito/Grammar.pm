# Do not edit this file - Generated by Perlito 6.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito::Perl5::Runtime;
use Perlito::Perl5::Prelude;
our $MATCH = Perlito::Match->new();
{
package GLOBAL;
sub new { shift; bless { @_ }, "GLOBAL" }

# use v6 
;
{
package Perlito::Grammar;
sub new { shift; bless { @_ }, "Perlito::Grammar" }
use Perlito::Expression;
use Perlito::Grammar::Regex;
use Perlito::Grammar::Control;
sub ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { (((do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((do { do { ((my  $m2 = undef) = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } }) } })); (($tmp)->{bool} = !Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } }) && (do { do { ((my  $m2 = undef) = $grammar->word($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((('_' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) } }) && (do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); for ( ; Main::bool(((do { do { ((my  $pos1 = undef) = $MATCH->to()); (((do { do { ((do { do { ((my  $m2 = undef) = $grammar->word($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } }) || (do { do { (($MATCH)->{to} = $pos1); (((('_' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((do { do { ((my  $m2 = undef) = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } })) } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) } }))); $MATCH };
sub full_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((do { do { ((my  $m2 = undef) = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); for ( ; Main::bool(((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((((('::' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do { do { ((my  $m2 = undef) = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) } }))); $MATCH };
sub namespace_before_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((((do { do { ((my  $m2 = undef) = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((('::' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to())))))) } }) } })); (($tmp)->{bool} = Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } })) && (do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); for ( ; Main::bool(((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((((('::' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) && (do { do { ((my  $m2 = undef) = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((('::' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to())))))) } }) } })); (($tmp)->{bool} = Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } }))) } }) } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) } }))); $MATCH };
sub optional_namespace_before_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { ((((do { do { ((my  $m2 = undef) = $grammar->namespace_before_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'namespace_before_ident'} = $m2); 1 } else { 0 } } }) && ((('::' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to())))))) && (((do { do { ($MATCH->{capture} = (("" . $MATCH->{'namespace_before_ident'}))) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((1 && (((do { do { ($MATCH->{capture} = ('')) } }) || 1)))) } })) } }))); $MATCH };
sub pod_begin { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { ((((do { do { ((my  $m2 = undef) = $grammar->is_newline($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && ((('=end' eq substr($str, $MATCH->to(), 4)) && ((($MATCH)->{to} = (4 + $MATCH->to())))))) && (do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); for ( ; Main::bool(((do { do { ((my  $m2 = undef) = $grammar->not_newline($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); for ( ; Main::bool(((do { do { ((my  $m2 = undef) = $grammar->not_newline($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } })) && (do { do { ((my  $m2 = undef) = $grammar->pod_begin($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } })) } }))); $MATCH };
sub ws { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); ((my  $count = undef) = 0); for ( ; Main::bool(((do { do { ((my  $pos1 = undef) = $MATCH->to()); (((do { do { ((((('#' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); for ( ; Main::bool(((do { do { ((my  $m2 = undef) = $grammar->not_newline($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { ((my  $m2 = undef) = $grammar->is_newline($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (do { do { ((my  $pos1 = undef) = $MATCH->to()); (((do { do { ((((('=begin' eq substr($str, $MATCH->to(), 6)) && ((($MATCH)->{to} = (6 + $MATCH->to()))))) && (do { do { ((my  $m2 = undef) = $grammar->pod_begin($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((('=for' eq substr($str, $MATCH->to(), 4)) && ((($MATCH)->{to} = (4 + $MATCH->to()))))) && (do { do { ((my  $m2 = undef) = $grammar->pod_begin($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } })) || (do { do { (($MATCH)->{to} = $pos1); (1) } })) } }))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((do { do { ((my  $m2 = undef) = $grammar->space($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } })) } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()); ($count = ($count + 1)) }; (($MATCH)->{to} = $last_pos); ($count > 0) } })) } }) } }))); $MATCH };
sub opt_ws { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((do { do { ((my  $last_pos = undef) = $MATCH->to()); if (Main::bool(!Main::bool((do { do { (do { do { ((my  $m2 = undef) = $grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } })))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) } }) } }))); $MATCH };
sub opt_ws2 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((do { do { ((my  $last_pos = undef) = $MATCH->to()); if (Main::bool(!Main::bool((do { do { (do { do { ((my  $m2 = undef) = $grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } })))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) } }) } }))); $MATCH };
sub opt_ws3 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((do { do { ((my  $last_pos = undef) = $MATCH->to()); if (Main::bool(!Main::bool((do { do { (do { do { ((my  $m2 = undef) = $grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } })))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) } }) } }))); $MATCH };
sub grammar { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((((((((do { do { ((my  $m2 = undef) = $grammar->full_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'full_ident'} = $m2); 1 } else { 0 } } }) && (do { do { ((my  $last_pos = undef) = $MATCH->to()); if (Main::bool(!Main::bool((do { do { (do { do { ((my  $m2 = undef) = $grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } })))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) && ((('{' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (do { do { ((my  $last_pos = undef) = $MATCH->to()); if (Main::bool(!Main::bool((do { do { (do { do { ((my  $m2 = undef) = $grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } })))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) && (do { do { ((my  $m2 = undef) = $grammar->exp_stmts($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'exp_stmts'} = $m2); 1 } else { 0 } } })) && (do { do { ((my  $last_pos = undef) = $MATCH->to()); if (Main::bool(!Main::bool((do { do { (do { do { ((my  $m2 = undef) = $grammar->ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } })))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) && ((('}' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do { do { ($MATCH->{capture} = (CompUnit->new(('name' => ${$MATCH->{'full_ident'}}), ('body' => ${$MATCH->{'exp_stmts'}})))) } }) || 1)))) } }) } }))); $MATCH };
sub declarator { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (((do { do { (((('my' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to())))))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((('state' eq substr($str, $MATCH->to(), 5)) && ((($MATCH)->{to} = (5 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((('has' eq substr($str, $MATCH->to(), 3)) && ((($MATCH)->{to} = (3 + $MATCH->to())))))) } })) } }))); $MATCH };
sub exp_stmts2 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((do { do { ((my  $m2 = undef) = $grammar->exp_stmts($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'exp_stmts'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'exp_stmts'}})) } }) || 1)))) } }) } }))); $MATCH };
sub exp { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((do { do { ((my  $m2 = undef) = Perlito::Expression->exp_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.exp_parse'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'Perlito::Expression.exp_parse'}})) } }) || 1)))) } }) } }))); $MATCH };
sub exp2 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((do { do { ((my  $m2 = undef) = Perlito::Expression->exp_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.exp_parse'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'Perlito::Expression.exp_parse'}})) } }) || 1)))) } }) } }))); $MATCH };
sub opt_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { (((do { do { ((my  $m2 = undef) = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'ident'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'ident'}})) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((1 && (((do { do { ($MATCH->{capture} = ('postcircumfix:<( )>')) } }) || 1)))) } })) } }))); $MATCH };
sub opt_type { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { ((((do { do { ((my  $last_pos = undef) = $MATCH->to()); if (Main::bool(!Main::bool((do { do { ((('::' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to()))))) } })))) { (($MATCH)->{to} = $last_pos) } ; 1 } }) && (do { do { ((my  $m2 = undef) = $grammar->full_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'full_ident'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'full_ident'}})) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((1 && (((do { do { ($MATCH->{capture} = ('')) } }) || 1)))) } })) } }))); $MATCH };
sub var_sigil { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((((do { do { (((('$' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((('%' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((('@' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((('&' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) } }))); $MATCH };
sub var_twigil { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((do { do { ((my  $last_pos = undef) = $MATCH->to()); if (Main::bool(!Main::bool((do { do { (do { do { ((my  $pos1 = undef) = $MATCH->to()); ((((do { do { (((('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((('!' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((('^' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((('*' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) } }) } })))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) } }) } }))); $MATCH };
sub var_name { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (((do { do { ((do { do { ((my  $m2 = undef) = $grammar->full_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'full_ident'} = $m2); 1 } else { 0 } } })) } }) || (do { do { (($MATCH)->{to} = $pos1); (((('/' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((do { do { ((my  $m2 = undef) = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'digit'} = $m2); 1 } else { 0 } } })) } })) } }))); $MATCH };
sub var_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((((((do { do { ((my  $m2 = undef) = $grammar->var_sigil($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'var_sigil'} = $m2); 1 } else { 0 } } }) && (do { do { ((my  $m2 = undef) = $grammar->var_twigil($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'var_twigil'} = $m2); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->optional_namespace_before_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'optional_namespace_before_ident'} = $m2); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->var_name($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'var_name'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (Var->new(('sigil' => ("" . $MATCH->{'var_sigil'})), ('twigil' => ("" . $MATCH->{'var_twigil'})), ('namespace' => ${$MATCH->{'optional_namespace_before_ident'}}), ('name' => ("" . $MATCH->{'var_name'}))))) } }) || 1)))) } }) } }))); $MATCH };
sub exponent { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { (((('e' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((('E' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) } }) && (do { do { ((my  $pos1 = undef) = $MATCH->to()); (((do { do { (((('+' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((('-' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (1) } })) } })) && (do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); ((my  $count = undef) = 0); for ( ; Main::bool(((do { do { ((my  $m2 = undef) = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()); ($count = ($count + 1)) }; (($MATCH)->{to} = $last_pos); ($count > 0) } }))) } }) } }))); $MATCH };
sub val_num { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { (((((('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); ((my  $count = undef) = 0); for ( ; Main::bool(((do { do { ((my  $m2 = undef) = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()); ($count = ($count + 1)) }; (($MATCH)->{to} = $last_pos); ($count > 0) } })) && (do { do { ((my  $last_pos = undef) = $MATCH->to()); if (Main::bool(!Main::bool((do { do { (do { do { ((my  $m2 = undef) = $grammar->exponent($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } })))) { (($MATCH)->{to} = $last_pos) } ; 1 } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); ((my  $count = undef) = 0); for ( ; Main::bool(((do { do { ((my  $m2 = undef) = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()); ($count = ($count + 1)) }; (($MATCH)->{to} = $last_pos); ($count > 0) } }) && (do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { ((do { do { ((my  $m2 = undef) = $grammar->exponent($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) } }) || (do { do { (($MATCH)->{to} = $pos1); (((((('.' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); ((my  $count = undef) = 0); for ( ; Main::bool(((do { do { ((my  $m2 = undef) = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()); ($count = ($count + 1)) }; (($MATCH)->{to} = $last_pos); ($count > 0) } })) && (do { do { ((my  $last_pos = undef) = $MATCH->to()); if (Main::bool(!Main::bool((do { do { (do { do { ((my  $m2 = undef) = $grammar->exponent($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) } })))) { (($MATCH)->{to} = $last_pos) } ; 1 } }))) } })) } }))) } })) } }) && (((do { do { ($MATCH->{capture} = (Val::Num->new(('num' => ("" . $MATCH))))) } }) || 1)))) } }) } }))); $MATCH };
sub char_any { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) } }))); $MATCH };
sub char_any_single_quote { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((((do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((('\'' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) } })); (($tmp)->{bool} = !Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } }) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); for ( ; Main::bool(((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { (((('\'' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((('\\' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) } })) } }) } })); (($tmp)->{bool} = !Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } }) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))) } }) } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) } }))); $MATCH };
sub single_quoted_unescape { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (((((do { do { ((((((('\\' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((('\\' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (do { do { ((my  $m2 = undef) = $grammar->single_quoted_unescape($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'single_quoted_unescape'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = ('\\' . $MATCH->{'single_quoted_unescape'})) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((((('\\' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((('\'' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (do { do { ((my  $m2 = undef) = $grammar->single_quoted_unescape($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'single_quoted_unescape'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = ('\'' . $MATCH->{'single_quoted_unescape'})) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((((('\\' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do { do { ((my  $m2 = undef) = $grammar->single_quoted_unescape($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'single_quoted_unescape'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = ('\\' . $MATCH->{'single_quoted_unescape'})) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { ((my  $m2 = undef) = $grammar->char_any_single_quote($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'char_any_single_quote'} = $m2); 1 } else { 0 } } }) && (do { do { ((my  $m2 = undef) = $grammar->single_quoted_unescape($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'single_quoted_unescape'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = ($MATCH->{'char_any_single_quote'} . $MATCH->{'single_quoted_unescape'})) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (1) } })) } }))); $MATCH };
sub char_any_double_quote { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((((do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (((((do { do { (((('"' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((('$' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((('@' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((('%' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((('{' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) } })) } }) } })); (($tmp)->{bool} = !Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } }) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); for ( ; Main::bool(((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((((((do { do { (((('"' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((('$' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((('@' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((('%' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((('{' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((('\\' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } })) } })) } }) } })); (($tmp)->{bool} = !Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } }) && ((('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))))) } }) } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }))) } }) } }))); $MATCH };
sub double_quoted_unescape { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((((do { do { (((((('\\' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((('n' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do { do { ($MATCH->{capture} = ('
')) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((((('\\' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && ((('t' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do { do { ($MATCH->{capture} = (chr(9))) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((((('\\' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do { do { ((my  $m2 = undef) = $grammar->char_any($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'char_any'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (("" . $MATCH->{'char_any'}))) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { ((my  $m2 = undef) = $grammar->char_any_double_quote($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'char_any_double_quote'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (("" . $MATCH->{'char_any_double_quote'}))) } }) || 1)))) } })) } }))); $MATCH };
sub double_quoted_buf { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (((((do { do { (((do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((('$' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) } })); (($tmp)->{bool} = Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } }) && (do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { ((((do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((((('$' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do { do { ((my  $m2 = undef) = $grammar->var_twigil($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) } })); (($tmp)->{bool} = Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } }) && (do { do { ((my  $m2 = undef) = Perlito::Expression->operator($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.operator'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = ((${$MATCH->{'Perlito::Expression.operator'}})->[1])) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { ((my  $m2 = undef) = $grammar->char_any($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'char_any'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (Val::Buf->new(('buf' => ("" . $MATCH->{'char_any'}))))) } }) || 1)))) } })) } }))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((('@' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) } })); (($tmp)->{bool} = Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } }) && (do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { (((((do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((((('@' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do { do { ((my  $m2 = undef) = $grammar->var_twigil($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) } })); (($tmp)->{bool} = Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } }) && (do { do { ((my  $m2 = undef) = Perlito::Expression->operator($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.operator'} = $m2); 1 } else { 0 } } })) && ((('[]' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to())))))) && (((do { do { ($MATCH->{capture} = ((${$MATCH->{'Perlito::Expression.operator'}})->[1])) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { ((my  $m2 = undef) = $grammar->char_any($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'char_any'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (Val::Buf->new(('buf' => ("" . $MATCH->{'char_any'}))))) } }) || 1)))) } })) } }))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((('%' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) } })); (($tmp)->{bool} = Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } }) && (do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { (((((do { do { ((my  $tmp = undef) = $MATCH); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $tmp->to()), ('to' => $tmp->to()), ('bool' => 1))); (($MATCH)->{bool} = (do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((((('%' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do { do { ((my  $m2 = undef) = $grammar->var_twigil($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }))) } }) } })); (($tmp)->{bool} = Main::bool($MATCH)); ($MATCH = $tmp); Main::bool($MATCH) } }) && (do { do { ((my  $m2 = undef) = Perlito::Expression->operator($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.operator'} = $m2); 1 } else { 0 } } })) && ((('{}' eq substr($str, $MATCH->to(), 2)) && ((($MATCH)->{to} = (2 + $MATCH->to())))))) && (((do { do { ($MATCH->{capture} = ((${$MATCH->{'Perlito::Expression.operator'}})->[1])) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { ((my  $m2 = undef) = $grammar->char_any($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'char_any'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (Val::Buf->new(('buf' => ("" . $MATCH->{'char_any'}))))) } }) || 1)))) } })) } }))) } })) || (do { do { (($MATCH)->{to} = $pos1); ((((((('{' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do { do { ((my  $m2 = undef) = $grammar->exp_stmts($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'exp_stmts'} = $m2); 1 } else { 0 } } })) && ((('}' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do { do { ($MATCH->{capture} = (Do->new(('block' => Lit::Block->new(('stmts' => ${$MATCH->{'exp_stmts'}})))))) } }) || 1)))) } })) || (do { do { (($MATCH)->{to} = $pos1); (((do { do { ((my  $m2 = undef) = $grammar->double_quoted_unescape($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'double_quoted_unescape'} = $m2); 1 } else { 0 } } }) && (((do { do { ($MATCH->{capture} = (Val::Buf->new(('buf' => ${$MATCH->{'double_quoted_unescape'}})))) } }) || 1)))) } })) } }))); $MATCH };
sub val_buf { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { ((((((('"' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); for ( ; Main::bool(((do { do { ((my  $m2 = undef) = $grammar->double_quoted_buf($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); if (Main::bool(exists($MATCH->{'double_quoted_buf'}))) { push( @{($MATCH->{'double_quoted_buf'})}, $m2 ) } else { ($MATCH->{'double_quoted_buf'} = do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, $m2 ); $List_a }) }; 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } })) && ((('"' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do { do { ((my  $args = undef) = $MATCH->{'double_quoted_buf'}); if (Main::bool(!Main::bool($args))) { ($MATCH->{capture} = (Val::Buf->new(('buf' => '')))) } else { ($MATCH->{capture} = (Apply->new(('namespace' => ''), ('code' => 'list:<~>'), ('arguments' => [ map { $_->capture() } @{ ($MATCH->{'double_quoted_buf'}) } ])))) } } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((((('\'' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))) && (do { do { ((my  $m2 = undef) = $grammar->single_quoted_unescape($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'single_quoted_unescape'} = $m2); 1 } else { 0 } } })) && ((('\'' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do { do { ($MATCH->{capture} = (Val::Buf->new(('buf' => ${$MATCH->{'single_quoted_unescape'}})))) } }) || 1)))) } })) } }))); $MATCH };
sub val_int { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); ((my  $count = undef) = 0); for ( ; Main::bool(((do { do { ((my  $m2 = undef) = $grammar->digit($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()); ($count = ($count + 1)) }; (($MATCH)->{to} = $last_pos); ($count > 0) } }) && (((do { do { ($MATCH->{capture} = (Val::Int->new(('int' => ("" . $MATCH))))) } }) || 1)))) } }) } }))); $MATCH };
sub exp_stmts { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((do { do { ((my  $last_match_null = undef) = 0); ((my  $last_pos = undef) = $MATCH->to()); for ( ; Main::bool(((do { do { ((my  $m2 = undef) = Perlito::Expression->delimited_statement($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); if (Main::bool(exists($MATCH->{'Perlito::Expression.delimited_statement'}))) { push( @{($MATCH->{'Perlito::Expression.delimited_statement'})}, $m2 ) } else { ($MATCH->{'Perlito::Expression.delimited_statement'} = do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, $m2 ); $List_a }) }; 1 } else { 0 } } }) && (($last_match_null < 2))));  ) { if (Main::bool(($last_pos == $MATCH->to()))) { ($last_match_null = ($last_match_null + 1)) } else { ($last_match_null = 0) }; ($last_pos = $MATCH->to()) }; (($MATCH)->{to} = $last_pos); 1 } }) && (((do { do { ($MATCH->{capture} = ([ map { $_->capture() } @{ $MATCH->{'Perlito::Expression.delimited_statement'} } ])) } }) || 1)))) } }) } }))); $MATCH };
sub opt_name { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { ((do { do { ((my  $last_pos = undef) = $MATCH->to()); if (Main::bool(!Main::bool((do { do { (do { do { ((my  $m2 = undef) = $grammar->ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); if (Main::bool(exists($MATCH->{'ident'}))) { push( @{($MATCH->{'ident'})}, $m2 ) } else { ($MATCH->{'ident'} = do { (my  $List_a = []); (my  $List_v = []); push( @{$List_a}, $m2 ); $List_a }) }; 1 } else { 0 } } }) } })))) { (($MATCH)->{to} = $last_pos) } ; 1 } })) } }) } }))); $MATCH };
sub var_invocant { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { ((((do { do { ((my  $m2 = undef) = $grammar->var_ident($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'var_ident'} = $m2); 1 } else { 0 } } }) && (((':' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'var_ident'}})) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { ($MATCH->{capture} = (Var->new(('sigil' => '$'), ('twigil' => ''), ('name' => 'self')))) } }) || 1))) } })) } }))); $MATCH };
sub args_sig { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((((do { do { ((my  $m2 = undef) = $grammar->var_invocant($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'var_invocant'} = $m2); 1 } else { 0 } } }) && (do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = Perlito::Expression->list_parse($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Expression.list_parse'} = $m2); 1 } else { 0 } } })) && (((do { do { ($MATCH->{capture} = (Sig->new(('invocant' => ${$MATCH->{'var_invocant'}}), ('positional' => Perlito::Expression::expand_list((${$MATCH->{'Perlito::Expression.list_parse'}})->{'exp'})), ('named' => do { (my  $Hash_a = {}); $Hash_a })))) } }) || 1)))) } }) } }))); $MATCH };
sub method_sig { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { ((((((((do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } }) && ((('(' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->args_sig($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'args_sig'} = $m2); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (((')' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do { do { ($MATCH->{capture} = (${$MATCH->{'args_sig'}})) } }) || 1)))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { ($MATCH->{capture} = (Sig->new(('invocant' => Var->new(('sigil' => '$'), ('twigil' => ''), ('name' => 'self'))), ('positional' => do { (my  $List_a = []); (my  $List_v = []); $List_a }), ('named' => do { (my  $Hash_a = {}); $Hash_a })))) } }) || 1))) } })) } }))); $MATCH };
sub method_def { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((((((((((do { do { ((my  $m2 = undef) = $grammar->opt_name($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'opt_name'} = $m2); 1 } else { 0 } } }) && (do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->method_sig($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'method_sig'} = $m2); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && ((('{' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->exp_stmts($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'exp_stmts'} = $m2); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { (((('}' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { die('Syntax Error in method \'.', ${$MATCH->{'name'}}, '\' near pos=', $MATCH->to()) } }) || 1))) } })) } })) && (((do { do { ($MATCH->{capture} = (Method->new(('name' => ${$MATCH->{'opt_name'}}), ('sig' => ${$MATCH->{'method_sig'}}), ('block' => ${$MATCH->{'exp_stmts'}})))) } }) || 1)))) } }) } }))); $MATCH };
sub sub_def { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((((((((((do { do { ((my  $m2 = undef) = $grammar->opt_name($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'opt_name'} = $m2); 1 } else { 0 } } }) && (do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->method_sig($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'method_sig'} = $m2); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && ((('{' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->exp_stmts($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'exp_stmts'} = $m2); 1 } else { 0 } } })) && (do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && (do { do { ((my  $pos1 = undef) = $MATCH->to()); ((do { do { (((('}' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) } }) || (do { do { (($MATCH)->{to} = $pos1); ((((do { do { die('Syntax Error in sub \'', ${$MATCH->{'name'}}, '\'') } }) || 1))) } })) } })) && (((do { do { ($MATCH->{capture} = (Sub->new(('name' => ${$MATCH->{'opt_name'}}), ('sig' => ${$MATCH->{'method_sig'}}), ('block' => ${$MATCH->{'exp_stmts'}})))) } }) || 1)))) } }) } }))); $MATCH };
sub token { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; (my  $MATCH = undef); ($MATCH = Perlito::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1))); (($MATCH)->{bool} = ((do { do { ((my  $pos1 = undef) = $MATCH->to()); (do { do { (((((((do { do { ((my  $m2 = undef) = $grammar->opt_name($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'opt_name'} = $m2); 1 } else { 0 } } }) && (do { do { ((my  $m2 = undef) = $grammar->opt_ws($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); 1 } else { 0 } } })) && ((('{' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (do { do { ((my  $m2 = undef) = Perlito::Grammar::Regex->rule($str, $MATCH->to())); if (Main::bool($m2)) { (($MATCH)->{to} = $m2->to()); ($MATCH->{'Perlito::Grammar::Regex.rule'} = $m2); 1 } else { 0 } } })) && ((('}' eq substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to())))))) && (((do { do { ((my  $source = undef) = $MATCH->{'opt_name'} . ' ( $grammar: $str, $pos ) { ' . 'my $MATCH; $MATCH = Perlito::Match.new( str => $str, from => $pos, to => $pos, bool => 1 ); ' . '$MATCH.bool = ( ' . (${$MATCH->{'Perlito::Grammar::Regex.rule'}})->emit_perl6() . '); ' . '$MATCH }'); ((my  $ast = undef) = Perlito::Grammar->method_def($source, 0)); ($MATCH->{capture} = (${$ast})) } }) || 1)))) } }) } }))); $MATCH }
}


}

1;
